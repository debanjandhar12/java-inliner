import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.NoSuchElementException;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.util.InputMismatchException;
import java.io.BufferedWriter;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.List;
// Import array ultils

public class Main2 {
    public static void main(String args[])  {
        InputReader in = new InputReader(System.in);
        int n = in.readIntPairArray(1)[0].first;
        int[] a = {1, 2, 3, 4, 5};
        int min = ArrayUtils.minElement(a);
        System.out.println(n);
    }
}
/**
 * @author Egor Kulikov (kulikov@devexperts.com)
 */
 class ArrayUtils {
    public static void fill(short[][] array, short value) {
        for (short[] row : array) {
            Arrays.fill(row, value);
        }
    }

    public static void fill(long[][] array, long value) {
        for (long[] row : array) {
            Arrays.fill(row, value);
        }
    }

    public static void fill(double[][] array, double value) {
        for (double[] row : array) {
            Arrays.fill(row, value);
        }
    }

    public static void fill(double[][][] array, double value) {
        for (double[][] row : array) {
            fill(row, value);
        }
    }

    public static void fill(double[][][][] array, double value) {
        for (double[][][] row : array) {
            fill(row, value);
        }
    }

    public static void fill(double[][][][][] array, double value) {
        for (double[][][][] row : array) {
            fill(row, value);
        }
    }

    public static void fill(long[][][] array, long value) {
        for (long[][] row : array) {
            fill(row, value);
        }
    }

    public static void fill(long[][][][] array, long value) {
        for (long[][][] row : array) {
            fill(row, value);
        }
    }

    public static void fill(long[][][][][] array, long value) {
        for (long[][][][] row : array) {
            fill(row, value);
        }
    }

    public static void fillColumn(long[][] array, int index, long value) {
        for (long[] row : array) {
            row[index] = value;
        }
    }

    public static void fillColumn(int[][] array, int index, int value) {
        for (int[] row : array) {
            row[index] = value;
        }
    }

    public static void fill(int[][] array, int value) {
        for (int[] row : array) {
            Arrays.fill(row, value);
        }
    }

    public static void fill(boolean[][] array, boolean value) {
        for (boolean[] row : array) {
            Arrays.fill(row, value);
        }
    }

    public static void fill(boolean[][][] array, boolean value) {
        for (boolean[][] row : array) {
            fill(row, value);
        }
    }

    public static long sumArray(int[] array) {
        return new IntArray(array).sum();
    }

    public static void fill(int[][][] array, int value) {
        for (int[][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(short[][][] array, short value) {
        for (short[][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(int[][][][] array, int value) {
        for (int[][][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(short[][][][] array, short value) {
        for (short[][][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(int[][][][][] array, int value) {
        for (int[][][][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(short[][][][][] array, short value) {
        for (short[][][][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(int[][][][][][] array, int value) {
        for (int[][][][][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(short[][][][][][] array, short value) {
        for (short[][][][][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(int[][][][][][][] array, int value) {
        for (int[][][][][][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(short[][][][][][][] array, short value) {
        for (short[][][][][][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static <T> void fill(T[][] array, T value) {
        for (T[] row : array) {
            Arrays.fill(row, value);
        }
    }

    public static void fill(char[][] array, char value) {
        for (char[] row : array) {
            Arrays.fill(row, value);
        }
    }

    public static void fill(byte[][] array, byte value) {
        for (byte[] row : array) {
            Arrays.fill(row, value);
        }
    }

    public static void fill(byte[][][] array, byte value) {
        for (byte[][] row : array) {
            fill(row, value);
        }
    }

    public static void fill(byte[][][][] array, byte value) {
        for (byte[][][] row : array) {
            fill(row, value);
        }
    }

    public static long multiply(int[] first, int[] second) {
        long result = 0;
        for (int i = 0; i < first.length; i++) {
            result += (long) first[i] * second[i];
        }
        return result;
    }

    public static int[] sort(int[] array) {
        return sort(array, IntComparator.DEFAULT);
    }

    public static int[] sort(int[] array, IntComparator comparator) {
        return sort(array, 0, array.length, comparator);
    }

    public static int[] sort(int[] array, int from, int to, IntComparator comparator) {
        if (from == 0 && to == array.length) {
            new IntArray(array).sort(comparator);
        } else {
            new IntArray(array).subList(from, to).sort(comparator);
        }
        return array;
    }

    public static int[] unique(int[] array) {
        return new IntArray(array).unique().toArray();
    }

    public static long[] unique(long[] array) {
        return new LongArray(array).unique().toArray();
    }

    public static char[] unique(char[] array) {
        return new CharArray(array).unique().toArray();
    }

    public static int maxElement(int[] array) {
        return new IntArray(array).max();
    }

    public static int maxElement(int[] array, int from, int to) {
        return new IntArray(array).subList(from, to).max();
    }

    public static int[] reversePermutation(int[] permutation) {
        int[] result = new int[permutation.length];
        for (int i = 0; i < permutation.length; i++) {
            result[permutation[i]] = i;
        }
        return result;
    }

    public static void reverse(int[] array) {
        new IntArray(array).inPlaceReverse();
    }

    public static void reverse(boolean[] array) {
        for (int i = 0, j = array.length - 1; i < j; i++, j--) {
            boolean temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }

    public static void reverse(long[] array) {
        new LongArray(array).inPlaceReverse();
    }

    public static void reverse(char[] array) {
        new CharArray(array).inPlaceReverse();
    }

    public static int minPosition(int[] array) {
        return new IntArray(array).minIndex();
    }

    public static int minPosition(long[] array) {
        return new LongArray(array).minIndex();
    }

    public static int maxPosition(int[] array) {
        return new IntArray(array).maxIndex();
    }

    public static int maxPosition(double[] array) {
        return new DoubleArray(array).maxIndex();
    }

    public static int minPosition(int[] array, int from, int to) {
        return new IntArray(array).subList(from, to).minIndex() + from;
    }

    public static int maxPosition(int[] array, int from, int to) {
        return new IntArray(array).subList(from, to).maxIndex() + from;
    }

    public static int[] multiplyPermutations(int[] first, int[] second) {
        int count = first.length;
        int[] result = new int[count];
        for (int i = 0; i < count; i++) {
            result[i] = first[second[i]];
        }
        return result;
    }

    public static int[] compress(int[]... arrays) {
        int totalLength = 0;
        for (int[] array : arrays) {
            totalLength += array.length;
        }
        int[] all = new int[totalLength];
        int delta = 0;
        for (int[] array : arrays) {
            System.arraycopy(array, 0, all, delta, array.length);
            delta += array.length;
        }
        sort(all, IntComparator.DEFAULT);
        all = unique(all);
        for (int[] array : arrays) {
            for (int i = 0; i < array.length; i++) {
                array[i] = Arrays.binarySearch(all, array[i]);
            }
        }
        return all;
    }

    public static long[] compress(long[]... arrays) {
        int totalLength = 0;
        for (long[] array : arrays) {
            totalLength += array.length;
        }
        long[] all = new long[totalLength];
        int delta = 0;
        for (long[] array : arrays) {
            System.arraycopy(array, 0, all, delta, array.length);
            delta += array.length;
        }
        new LongArray(all).sort();
        all = unique(all);
        for (long[] array : arrays) {
            for (int i = 0; i < array.length; i++) {
                array[i] = Arrays.binarySearch(all, array[i]);
            }
        }
        return all;
    }

    public static int minElement(int[] array) {
        return new IntArray(array).min();
    }

    public static long[] partialSums(int[] array) {
        long[] result = new long[array.length + 1];
        for (int i = 0; i < array.length; i++) {
            result[i + 1] = result[i] + array[i];
        }
        return result;
    }


    public static void order(int[] order, int[] array) {
        int[] tempInt = new int[order.length];
        for (int i = 0; i < order.length; i++) {
            tempInt[i] = array[order[i]];
        }
        System.arraycopy(tempInt, 0, array, 0, array.length);
    }

    public static void order(int[] order, char[] array) {
        char[] tempChar = new char[order.length];
        for (int i = 0; i < order.length; i++) {
            tempChar[i] = array[order[i]];
        }
        System.arraycopy(tempChar, 0, array, 0, array.length);
    }

    public static void order(int[] order, long[] array) {
        long[] tempLong = new long[order.length];
        for (int i = 0; i < order.length; i++) {
            tempLong[i] = array[order[i]];
        }
        System.arraycopy(tempLong, 0, array, 0, array.length);
    }

    public static long[] asLong(int[] array) {
        long[] result = new long[array.length];
        for (int i = 0; i < array.length; i++) {
            result[i] = array[i];
        }
        return result;
    }

    public static int count(int[] array, int value) {
        return new IntArray(array).count(value);
    }

    public static int count(long[] array, long value) {
        return new LongArray(array).count(value);
    }

    public static int count(double[] array, double value) {
        return new DoubleArray(array).count(value);
    }

    public static int count(char[] array, char value) {
        return new CharArray(array).count(value);
    }

    public static int count(boolean[] array, boolean value) {
        int result = 0;
        for (boolean i : array) {
            if (i == value) {
                result++;
            }
        }
        return result;
    }

    public static int[] merge(int[] first, int[] second) {
        int[] result = new int[first.length + second.length];
        int firstIndex = 0;
        int secondIndex = 0;
        int index = 0;
        while (firstIndex < first.length && secondIndex < second.length) {
            if (first[firstIndex] < second[secondIndex]) {
                result[index++] = first[firstIndex++];
            } else {
                result[index++] = second[secondIndex++];
            }
        }
        System.arraycopy(first, firstIndex, result, index, first.length - firstIndex);
        System.arraycopy(second, secondIndex, result, index, second.length - secondIndex);
        return result;
    }

    public static boolean nextPermutation(int[] array) {
        return new IntArray(array).nextPermutation();
    }

    public static <V> void reverse(V[] array) {
        for (int i = 0, j = array.length - 1; i < j; i++, j--) {
            V temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }

    public static IntComparator compareBy(final int[]... arrays) {
        return new IntComparator() {
            public int compare(int first, int second) {
                for (int[] array : arrays) {
                    if (array[first] != array[second]) {
                        return Integer.compare(array[first], array[second]);
                    }
                }
                return 0;
            }
        };
    }

    public static long minElement(long[] array) {
        return new LongArray(array).min();
    }

    public static long maxElement(long[] array) {
        return new LongArray(array).max();
    }

    public static int maxPosition(long[] array) {
        return new LongArray(array).maxIndex();
    }

    public static int maxPosition(long[] array, int from, int to) {
        return new LongArray(array).subList(from, to).maxIndex() + from;
    }

    public static int[] createArray(int count, int value) {
        int[] array = new int[count];
        Arrays.fill(array, value);
        return array;
    }

    public static long[] createArray(int count, long value) {
        long[] array = new long[count];
        Arrays.fill(array, value);
        return array;
    }

    public static double[] createArray(int count, double value) {
        double[] array = new double[count];
        Arrays.fill(array, value);
        return array;
    }

    public static boolean[] createArray(int count, boolean value) {
        boolean[] array = new boolean[count];
        Arrays.fill(array, value);
        return array;
    }

    public static char[] createArray(int count, char value) {
        char[] array = new char[count];
        Arrays.fill(array, value);
        return array;
    }

    public static <T> T[] createArray(int count, T value) {
        @SuppressWarnings("unchecked")
        T[] array = (T[]) Array.newInstance(value.getClass(), count);
        Arrays.fill(array, value);
        return array;
    }

    public static long[][] partialSums(int[][] array) {
        int height = array.length;
        int width = array[0].length;
        long[][] result = new long[height + 1][width + 1];
        for (int i = 1; i <= height; i++) {
            for (int j = 1; j <= width; j++) {
                result[i][j] = result[i][j - 1] + result[i - 1][j] - result[i - 1][j - 1] + array[i - 1][j - 1];
            }
        }
        return result;
    }

    public static long[][] partialSums(long[][] array) {
        int height = array.length;
        int width = array[0].length;
        long[][] result = new long[height + 1][width + 1];
        for (int i = 1; i <= height; i++) {
            for (int j = 1; j <= width; j++) {
                result[i][j] = result[i][j - 1] + result[i - 1][j] - result[i - 1][j - 1] + array[i - 1][j - 1];
            }
        }
        return result;
    }

    public static int[][] transpose(int[][] array) {
        if (array.length == 0) {
            return new int[0][0];
        }
        int[][] result = new int[array[0].length][array.length];
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array[i].length; j++) {
                result[j][i] = array[i][j];
            }
        }
        return result;
    }

    public static int find(int[] array, int value) {
        return new IntArray(array).find(value);
    }

    public static int find(char[] array, char value) {
        return new CharArray(array).find(value);
    }

    public static long[] concatenate(long[] arr1, long[] arr2) {
        long[] result = Arrays.copyOf(arr1, arr1.length + arr2.length);
        System.arraycopy(arr2, 0, result, arr1.length, arr2.length);
        return result;
    }

    public static char[] concatenate(char[] arr1, char[] arr2) {
        char[] result = Arrays.copyOf(arr1, arr1.length + arr2.length);
        System.arraycopy(arr2, 0, result, arr1.length, arr2.length);
        return result;
    }

    public static int[] concatenate(int[] arr1, int[] arr2) {
        int[] result = Arrays.copyOf(arr1, arr1.length + arr2.length);
        System.arraycopy(arr2, 0, result, arr1.length, arr2.length);
        return result;
    }
}
class LongArray extends LongAbstractStream implements LongList {
    private long[] data;

    public LongArray(long[] arr) {
        data = arr;
    }

    public int size() {
        return data.length;
    }

    public long get(int at) {
        return data[at];
    }

    public void addAt(int index, long value) {
        throw new UnsupportedOperationException();
    }

    public void removeAt(int index) {
        throw new UnsupportedOperationException();
    }

    public void set(int index, long value) {
        data[index] = value;
    }
}
abstract class LongAbstractStream implements LongStream {
    //base
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        boolean first = true;
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            if (first) {
                first = false;
            } else {
                builder.append(' ');
            }
            builder.append(it.value());
        }
        return builder.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof LongStream)) {
            return false;
        }
        LongStream c = (LongStream) o;
        LongIterator it = longIterator();
        LongIterator jt = c.longIterator();
        while (it.isValid() && jt.isValid()) {
            if (it.value() != jt.value()) {
                return false;
            }
            it.advance();
            jt.advance();
        }
        return !it.isValid() && !jt.isValid();
    }

    @Override
    public int hashCode() {
        int result = 0;
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            result *= 31;
            result += it.value();
        }
        return result;
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongIterator {
    public long value() throws NoSuchElementException;

    /**
     * Returns true if next call to isValid will return true
     */
    public boolean advance();

    public boolean isValid();

    public void remove();
}
class IntArray extends IntAbstractStream implements IntList {
    private int[] data;

    public IntArray(int[] arr) {
        data = arr;
    }

    public int size() {
        return data.length;
    }

    public int get(int at) {
        return data[at];
    }

    public void addAt(int index, int value) {
        throw new UnsupportedOperationException();
    }

    public void removeAt(int index) {
        throw new UnsupportedOperationException();
    }

    public void set(int index, int value) {
        data[index] = value;
    }
}
abstract class IntAbstractStream implements IntStream {
    //base
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        boolean first = true;
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            if (first) {
                first = false;
            } else {
                builder.append(' ');
            }
            builder.append(it.value());
        }
        return builder.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof IntStream)) {
            return false;
        }
        IntStream c = (IntStream) o;
        IntIterator it = intIterator();
        IntIterator jt = c.intIterator();
        while (it.isValid() && jt.isValid()) {
            if (it.value() != jt.value()) {
                return false;
            }
            it.advance();
            jt.advance();
        }
        return !it.isValid() && !jt.isValid();
    }

    @Override
    public int hashCode() {
        int result = 0;
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            result *= 31;
            result += it.value();
        }
        return result;
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntIterator {
    public int value() throws NoSuchElementException;

    /**
     * Returns true if next call to isValid will return true
     */
    public boolean advance();

    public boolean isValid();

    public void remove();
}
class DoubleArray extends DoubleAbstractStream implements DoubleList {
    private double[] data;

    public DoubleArray(double[] arr) {
        data = arr;
    }

    public int size() {
        return data.length;
    }

    public double get(int at) {
        return data[at];
    }

    public void addAt(int index, double value) {
        throw new UnsupportedOperationException();
    }

    public void removeAt(int index) {
        throw new UnsupportedOperationException();
    }

    public void set(int index, double value) {
        data[index] = value;
    }
}
abstract class DoubleAbstractStream implements DoubleStream {
    //base
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        boolean first = true;
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            if (first) {
                first = false;
            } else {
                builder.append(' ');
            }
            builder.append(it.value());
        }
        return builder.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof DoubleStream)) {
            return false;
        }
        DoubleStream c = (DoubleStream) o;
        DoubleIterator it = doubleIterator();
        DoubleIterator jt = c.doubleIterator();
        while (it.isValid() && jt.isValid()) {
            if (it.value() != jt.value()) {
                return false;
            }
            it.advance();
            jt.advance();
        }
        return !it.isValid() && !jt.isValid();
    }

    @Override
    public int hashCode() {
        int result = 0;
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            result *= 31;
            result += it.value();
        }
        return result;
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleIterator {
    public double value() throws NoSuchElementException;

    /**
     * Returns true if next call to isValid will return true
     */
    public boolean advance();

    public boolean isValid();

    public void remove();
}
class CharArray extends CharAbstractStream implements CharList {
    private char[] data;

    public CharArray(char[] arr) {
        data = arr;
    }

    public int size() {
        return data.length;
    }

    public char get(int at) {
        return data[at];
    }

    public void addAt(int index, char value) {
        throw new UnsupportedOperationException();
    }

    public void removeAt(int index) {
        throw new UnsupportedOperationException();
    }

    public void set(int index, char value) {
        data[index] = value;
    }
}
abstract class CharAbstractStream implements CharStream {
    //base
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        boolean first = true;
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            if (first) {
                first = false;
            } else {
                builder.append(' ');
            }
            builder.append(it.value());
        }
        return builder.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof CharStream)) {
            return false;
        }
        CharStream c = (CharStream) o;
        CharIterator it = charIterator();
        CharIterator jt = c.charIterator();
        while (it.isValid() && jt.isValid()) {
            if (it.value() != jt.value()) {
                return false;
            }
            it.advance();
            jt.advance();
        }
        return !it.isValid() && !jt.isValid();
    }

    @Override
    public int hashCode() {
        int result = 0;
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            result *= 31;
            result += it.value();
        }
        return result;
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharIterator {
    public char value() throws NoSuchElementException;

    /**
     * Returns true if next call to isValid will return true
     */
    public boolean advance();

    public boolean isValid();

    public void remove();
}
/**
 * @author Egor Kulikov
 */
 interface IntComparator {
    public static final IntComparator DEFAULT = (first, second) -> {
        if (first < second) {
            return -1;
        }
        if (first > second) {
            return 1;
        }
        return 0;
    };

    public static final IntComparator REVERSE = (first, second) -> {
        if (first > second) {
            return -1;
        }
        if (first < second) {
            return 1;
        }
        return 0;
    };

    public int compare(int first, int second);
}
/**
 * @author Egor Kulikov (kulikov@devexperts.com)
 */
 class InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public double[] readDoubleArray(int size) {
        double[] array = new double[size];
        for (int i = 0; i < size; i++) {
            array[i] = readDouble();
        }
        return array;
    }

    public String[] readStringArray(int size) {
        String[] array = new String[size];
        for (int i = 0; i < size; i++) {
            array[i] = readString();
        }
        return array;
    }

    public char[] readCharArray(int size) {
        char[] array = new char[size];
        for (int i = 0; i < size; i++) {
            array[i] = readCharacter();
        }
        return array;
    }

    public IntIntPair[] readIntPairArray(int size) {
        IntIntPair[] result = new IntIntPair[size];
        for (int i = 0; i < size; i++) {
            result[i] = readIntPair();
        }
        return result;
    }

    public LongLongPair[] readLongPairArray(int size) {
        LongLongPair[] result = new LongLongPair[size];
        for (int i = 0; i < size; i++) {
            result[i] = readLongPair();
        }
        return result;
    }

    public void readIntArrays(int[]... arrays) {
        for (int i = 0; i < arrays[0].length; i++) {
            for (int j = 0; j < arrays.length; j++) {
                arrays[j][i] = readInt();
            }
        }
    }

    public void readLongArrays(long[]... arrays) {
        for (int i = 0; i < arrays[0].length; i++) {
            for (int j = 0; j < arrays.length; j++) {
                arrays[j][i] = readLong();
            }
        }
    }

    public void readDoubleArrays(double[]... arrays) {
        for (int i = 0; i < arrays[0].length; i++) {
            for (int j = 0; j < arrays.length; j++) {
                arrays[j][i] = readDouble();
            }
        }
    }

    public char[][] readTable(int rowCount, int columnCount) {
        char[][] table = new char[rowCount][];
        for (int i = 0; i < rowCount; i++) {
            table[i] = this.readCharArray(columnCount);
        }
        return table;
    }

    public int[][] readIntTable(int rowCount, int columnCount) {
        int[][] table = new int[rowCount][];
        for (int i = 0; i < rowCount; i++) {
            table[i] = readIntArray(columnCount);
        }
        return table;
    }

    public double[][] readDoubleTable(int rowCount, int columnCount) {
        double[][] table = new double[rowCount][];
        for (int i = 0; i < rowCount; i++) {
            table[i] = this.readDoubleArray(columnCount);
        }
        return table;
    }

    public long[][] readLongTable(int rowCount, int columnCount) {
        long[][] table = new long[rowCount][];
        for (int i = 0; i < rowCount; i++) {
            table[i] = readLongArray(columnCount);
        }
        return table;
    }

    public String[][] readStringTable(int rowCount, int columnCount) {
        String[][] table = new String[rowCount][];
        for (int i = 0; i < rowCount; i++) {
            table[i] = this.readStringArray(columnCount);
        }
        return table;
    }

    public String readText() {
        StringBuilder result = new StringBuilder();
        while (true) {
            int character = read();
            if (character == '\r') {
                continue;
            }
            if (character == -1) {
                break;
            }
            result.append((char) character);
        }
        return result.toString();
    }

    public void readStringArrays(String[]... arrays) {
        for (int i = 0; i < arrays[0].length; i++) {
            for (int j = 0; j < arrays.length; j++) {
                arrays[j][i] = readString();
            }
        }
    }

    public long[] readLongArray(int size) {
        long[] array = new long[size];
        for (int i = 0; i < size; i++) {
            array[i] = readLong();
        }
        return array;
    }

    public int[] readIntArray(int size) {
        int[] array = new int[size];
        for (int i = 0; i < size; i++) {
            array[i] = readInt();
        }
        return array;
    }

    public LongLongPair readLongPair() {
        long first = readLong();
        long second = readLong();
        return new LongLongPair(first, second);
    }

    public IntIntPair readIntPair() {
        int first = readInt();
        int second = readInt();
        return new IntIntPair(first, second);
    }

    public int read() {
        if (numChars == -1) {
            throw new InputMismatchException();
        }
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0) {
                return -1;
            }
        }
        return buf[curChar++];
    }

    public int peek() {
        if (numChars == -1) {
            return -1;
        }
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                return -1;
            }
            if (numChars <= 0) {
                return -1;
            }
        }
        return buf[curChar];
    }

    public int peekNonWhitespace() {
        while (isWhitespace(peek())) {
            read();
        }
        return peek();
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9') {
                throw new InputMismatchException();
            }
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public long readLong() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        long res = 0;
        do {
            if (c < '0' || c > '9') {
                throw new InputMismatchException();
            }
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public String readString() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        StringBuilder res = new StringBuilder();
        do {
            if (Character.isValidCodePoint(c)) {
                res.appendCodePoint(c);
            }
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    public boolean isSpaceChar(int c) {
        if (filter != null) {
            return filter.isSpaceChar(c);
        }
        return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    private String readLine0() {
        StringBuilder buf = new StringBuilder();
        int c = read();
        while (c != '\n' && c != -1) {
            if (c != '\r') {
                buf.appendCodePoint(c);
            }
            c = read();
        }
        return buf.toString();
    }

    public String readLine() {
        String s = readLine0();
        while (s.trim().length() == 0) {
            s = readLine0();
        }
        return s;
    }

    public String readLine(boolean ignoreEmptyLines) {
        if (ignoreEmptyLines) {
            return readLine();
        } else {
            return readLine0();
        }
    }

    public BigInteger readBigInteger() {
        try {
            return new BigInteger(readString());
        } catch (NumberFormatException e) {
            throw new InputMismatchException();
        }
    }

    public char readCharacter() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        return (char) c;
    }

    public double readDouble() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        double res = 0;
        while (!isSpaceChar(c) && c != '.') {
            if (c == 'e' || c == 'E') {
                return res * Math.pow(10, readInt());
            }
            if (c < '0' || c > '9') {
                throw new InputMismatchException();
            }
            res *= 10;
            res += c - '0';
            c = read();
        }
        if (c == '.') {
            c = read();
            double m = 1;
            while (!isSpaceChar(c)) {
                if (c == 'e' || c == 'E') {
                    return res * Math.pow(10, readInt());
                }
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                m /= 10;
                res += (c - '0') * m;
                c = read();
            }
        }
        return res * sgn;
    }

    public boolean isExhausted() {
        int value;
        while (isSpaceChar(value = peek()) && value != -1) {
            read();
        }
        return value == -1;
    }

    public String next() {
        return readString();
    }

    public SpaceCharFilter getFilter() {
        return filter;
    }

    public void setFilter(SpaceCharFilter filter) {
        this.filter = filter;
    }

     interface SpaceCharFilter {
        public boolean isSpaceChar(int ch);
    }
}
/**
 * @author Egor Kulikov (egor@egork.net)
 */
 class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
        this.writer = new PrintWriter(writer);
    }

    public void printTable(char[][] table) {
        for (char[] row : table) {
            printLine(new String(row));
        }
    }

    public void print(char[] array) {
        writer.print(array);
    }

    public void print(Object... objects) {
        for (int i = 0; i < objects.length; i++) {
            if (i != 0) {
                writer.print(' ');
            }
            writer.print(objects[i]);
        }
    }

    public void print(int[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0) {
                writer.print(' ');
            }
            writer.print(array[i]);
        }
    }

    public void print(double[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0) {
                writer.print(' ');
            }
            writer.print(array[i]);
        }
    }

    public void print(long[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0) {
                writer.print(' ');
            }
            writer.print(array[i]);
        }
    }

    public void printLine(int[] array) {
        print(array);
        writer.println();
    }

    public void printLine(double[] array) {
        print(array);
        writer.println();
    }

    public void printLine(long[] array) {
        print(array);
        writer.println();
    }

    public void printLine() {
        writer.println();
    }

    public void printLine(Object... objects) {
        print(objects);
        writer.println();
    }

    public void print(char i) {
        writer.print(i);
    }

    public void printLine(char i) {
        writer.println(i);
    }

    public void printLine(char[] array) {
        writer.println(array);
    }

    public void printFormat(String format, Object... objects) {
        writer.printf(format, objects);
    }

    public void close() {
        writer.close();
    }

    public void flush() {
        writer.flush();
    }

    public void print(long i) {
        writer.print(i);
    }

    public void printLine(long i) {
        writer.println(i);
    }

    public void print(int i) {
        writer.print(i);
    }

    public void printLine(int i) {
        writer.println(i);
    }

    public void separateLines(int[] array) {
        for (int i : array) {
            printLine(i);
        }
    }

    public void printList(List<?> answer) {
        for (Object o : answer) {
            printLine(o);
        }
    }

    public void printPairList(List<IntIntPair> answer) {
        for (IntIntPair pair : answer) {
            printLine(pair.first, pair.second);
        }
    }
}
/**
 * @author Egor Kulikov
 */
 class IntIntPair implements Comparable<IntIntPair> {
    public final int first;
    public final int second;

    public static IntIntPair makePair(int first, int second) {
        return new IntIntPair(first, second);
    }

    public IntIntPair(int first, int second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        IntIntPair pair = (IntIntPair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = first;
        result = 31 * result + second;
        return result;
    }

    public IntIntPair swap() {
        return IntIntPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(IntIntPair o) {
        int value = Integer.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Integer.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class LongLongPair implements Comparable<LongLongPair> {
    public final long first;
    public final long second;

    public static LongLongPair makePair(long first, long second) {
        return new LongLongPair(first, second);
    }

    public LongLongPair(long first, long second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        LongLongPair pair = (LongLongPair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = Long.hashCode(first);
        result = 31 * result + Long.hashCode(second);
        return result;
    }

    public LongLongPair swap() {
        return LongLongPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(LongLongPair o) {
        int value = Long.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Long.compare(second, o.second);
    }
}