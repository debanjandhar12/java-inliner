import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Random;
import java.util.NoSuchElementException;
import java.util.Iterator;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.util.InputMismatchException;
import java.io.BufferedWriter;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.List;
// Import array ultils

public class Main2 {
    public static void main(String args[])  {
        InputReader in = new InputReader(System.in);
        int n = in.readIntPairArray(1)[0].first;
        int[] a = {1, 2, 3, 4, 5};
        int min = ArrayUtils.minElement(a);
        System.out.println(n);
    }
}
/**
 * @author Egor Kulikov (kulikov@devexperts.com)
 */
 class ArrayUtils {
    public static void fill(short[][] array, short value) {
        for (short[] row : array) {
            Arrays.fill(row, value);
        }
    }

    public static void fill(long[][] array, long value) {
        for (long[] row : array) {
            Arrays.fill(row, value);
        }
    }

    public static void fill(double[][] array, double value) {
        for (double[] row : array) {
            Arrays.fill(row, value);
        }
    }

    public static void fill(double[][][] array, double value) {
        for (double[][] row : array) {
            fill(row, value);
        }
    }

    public static void fill(double[][][][] array, double value) {
        for (double[][][] row : array) {
            fill(row, value);
        }
    }

    public static void fill(double[][][][][] array, double value) {
        for (double[][][][] row : array) {
            fill(row, value);
        }
    }

    public static void fill(long[][][] array, long value) {
        for (long[][] row : array) {
            fill(row, value);
        }
    }

    public static void fill(long[][][][] array, long value) {
        for (long[][][] row : array) {
            fill(row, value);
        }
    }

    public static void fill(long[][][][][] array, long value) {
        for (long[][][][] row : array) {
            fill(row, value);
        }
    }

    public static void fillColumn(long[][] array, int index, long value) {
        for (long[] row : array) {
            row[index] = value;
        }
    }

    public static void fillColumn(int[][] array, int index, int value) {
        for (int[] row : array) {
            row[index] = value;
        }
    }

    public static void fill(int[][] array, int value) {
        for (int[] row : array) {
            Arrays.fill(row, value);
        }
    }

    public static void fill(boolean[][] array, boolean value) {
        for (boolean[] row : array) {
            Arrays.fill(row, value);
        }
    }

    public static void fill(boolean[][][] array, boolean value) {
        for (boolean[][] row : array) {
            fill(row, value);
        }
    }

    public static long sumArray(int[] array) {
        return new IntArray(array).sum();
    }

    public static void fill(int[][][] array, int value) {
        for (int[][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(short[][][] array, short value) {
        for (short[][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(int[][][][] array, int value) {
        for (int[][][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(short[][][][] array, short value) {
        for (short[][][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(int[][][][][] array, int value) {
        for (int[][][][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(short[][][][][] array, short value) {
        for (short[][][][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(int[][][][][][] array, int value) {
        for (int[][][][][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(short[][][][][][] array, short value) {
        for (short[][][][][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(int[][][][][][][] array, int value) {
        for (int[][][][][][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static void fill(short[][][][][][][] array, short value) {
        for (short[][][][][][] subArray : array) {
            fill(subArray, value);
        }
    }

    public static <T> void fill(T[][] array, T value) {
        for (T[] row : array) {
            Arrays.fill(row, value);
        }
    }

    public static void fill(char[][] array, char value) {
        for (char[] row : array) {
            Arrays.fill(row, value);
        }
    }

    public static void fill(byte[][] array, byte value) {
        for (byte[] row : array) {
            Arrays.fill(row, value);
        }
    }

    public static void fill(byte[][][] array, byte value) {
        for (byte[][] row : array) {
            fill(row, value);
        }
    }

    public static void fill(byte[][][][] array, byte value) {
        for (byte[][][] row : array) {
            fill(row, value);
        }
    }

    public static long multiply(int[] first, int[] second) {
        long result = 0;
        for (int i = 0; i < first.length; i++) {
            result += (long) first[i] * second[i];
        }
        return result;
    }

    public static int[] sort(int[] array) {
        return sort(array, IntComparator.DEFAULT);
    }

    public static int[] sort(int[] array, IntComparator comparator) {
        return sort(array, 0, array.length, comparator);
    }

    public static int[] sort(int[] array, int from, int to, IntComparator comparator) {
        if (from == 0 && to == array.length) {
            new IntArray(array).sort(comparator);
        } else {
            new IntArray(array).subList(from, to).sort(comparator);
        }
        return array;
    }

    public static int[] unique(int[] array) {
        return new IntArray(array).unique().toArray();
    }

    public static long[] unique(long[] array) {
        return new LongArray(array).unique().toArray();
    }

    public static char[] unique(char[] array) {
        return new CharArray(array).unique().toArray();
    }

    public static int maxElement(int[] array) {
        return new IntArray(array).max();
    }

    public static int maxElement(int[] array, int from, int to) {
        return new IntArray(array).subList(from, to).max();
    }

    public static int[] reversePermutation(int[] permutation) {
        int[] result = new int[permutation.length];
        for (int i = 0; i < permutation.length; i++) {
            result[permutation[i]] = i;
        }
        return result;
    }

    public static void reverse(int[] array) {
        new IntArray(array).inPlaceReverse();
    }

    public static void reverse(boolean[] array) {
        for (int i = 0, j = array.length - 1; i < j; i++, j--) {
            boolean temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }

    public static void reverse(long[] array) {
        new LongArray(array).inPlaceReverse();
    }

    public static void reverse(char[] array) {
        new CharArray(array).inPlaceReverse();
    }

    public static int minPosition(int[] array) {
        return new IntArray(array).minIndex();
    }

    public static int minPosition(long[] array) {
        return new LongArray(array).minIndex();
    }

    public static int maxPosition(int[] array) {
        return new IntArray(array).maxIndex();
    }

    public static int maxPosition(double[] array) {
        return new DoubleArray(array).maxIndex();
    }

    public static int minPosition(int[] array, int from, int to) {
        return new IntArray(array).subList(from, to).minIndex() + from;
    }

    public static int maxPosition(int[] array, int from, int to) {
        return new IntArray(array).subList(from, to).maxIndex() + from;
    }

    public static int[] multiplyPermutations(int[] first, int[] second) {
        int count = first.length;
        int[] result = new int[count];
        for (int i = 0; i < count; i++) {
            result[i] = first[second[i]];
        }
        return result;
    }

    public static int[] compress(int[]... arrays) {
        int totalLength = 0;
        for (int[] array : arrays) {
            totalLength += array.length;
        }
        int[] all = new int[totalLength];
        int delta = 0;
        for (int[] array : arrays) {
            System.arraycopy(array, 0, all, delta, array.length);
            delta += array.length;
        }
        sort(all, IntComparator.DEFAULT);
        all = unique(all);
        for (int[] array : arrays) {
            for (int i = 0; i < array.length; i++) {
                array[i] = Arrays.binarySearch(all, array[i]);
            }
        }
        return all;
    }

    public static long[] compress(long[]... arrays) {
        int totalLength = 0;
        for (long[] array : arrays) {
            totalLength += array.length;
        }
        long[] all = new long[totalLength];
        int delta = 0;
        for (long[] array : arrays) {
            System.arraycopy(array, 0, all, delta, array.length);
            delta += array.length;
        }
        new LongArray(all).sort();
        all = unique(all);
        for (long[] array : arrays) {
            for (int i = 0; i < array.length; i++) {
                array[i] = Arrays.binarySearch(all, array[i]);
            }
        }
        return all;
    }

    public static int minElement(int[] array) {
        return new IntArray(array).min();
    }

    public static long[] partialSums(int[] array) {
        long[] result = new long[array.length + 1];
        for (int i = 0; i < array.length; i++) {
            result[i + 1] = result[i] + array[i];
        }
        return result;
    }


    public static void order(int[] order, int[] array) {
        int[] tempInt = new int[order.length];
        for (int i = 0; i < order.length; i++) {
            tempInt[i] = array[order[i]];
        }
        System.arraycopy(tempInt, 0, array, 0, array.length);
    }

    public static void order(int[] order, char[] array) {
        char[] tempChar = new char[order.length];
        for (int i = 0; i < order.length; i++) {
            tempChar[i] = array[order[i]];
        }
        System.arraycopy(tempChar, 0, array, 0, array.length);
    }

    public static void order(int[] order, long[] array) {
        long[] tempLong = new long[order.length];
        for (int i = 0; i < order.length; i++) {
            tempLong[i] = array[order[i]];
        }
        System.arraycopy(tempLong, 0, array, 0, array.length);
    }

    public static long[] asLong(int[] array) {
        long[] result = new long[array.length];
        for (int i = 0; i < array.length; i++) {
            result[i] = array[i];
        }
        return result;
    }

    public static int count(int[] array, int value) {
        return new IntArray(array).count(value);
    }

    public static int count(long[] array, long value) {
        return new LongArray(array).count(value);
    }

    public static int count(double[] array, double value) {
        return new DoubleArray(array).count(value);
    }

    public static int count(char[] array, char value) {
        return new CharArray(array).count(value);
    }

    public static int count(boolean[] array, boolean value) {
        int result = 0;
        for (boolean i : array) {
            if (i == value) {
                result++;
            }
        }
        return result;
    }

    public static int[] merge(int[] first, int[] second) {
        int[] result = new int[first.length + second.length];
        int firstIndex = 0;
        int secondIndex = 0;
        int index = 0;
        while (firstIndex < first.length && secondIndex < second.length) {
            if (first[firstIndex] < second[secondIndex]) {
                result[index++] = first[firstIndex++];
            } else {
                result[index++] = second[secondIndex++];
            }
        }
        System.arraycopy(first, firstIndex, result, index, first.length - firstIndex);
        System.arraycopy(second, secondIndex, result, index, second.length - secondIndex);
        return result;
    }

    public static boolean nextPermutation(int[] array) {
        return new IntArray(array).nextPermutation();
    }

    public static <V> void reverse(V[] array) {
        for (int i = 0, j = array.length - 1; i < j; i++, j--) {
            V temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }

    public static IntComparator compareBy(final int[]... arrays) {
        return new IntComparator() {
            public int compare(int first, int second) {
                for (int[] array : arrays) {
                    if (array[first] != array[second]) {
                        return Integer.compare(array[first], array[second]);
                    }
                }
                return 0;
            }
        };
    }

    public static long minElement(long[] array) {
        return new LongArray(array).min();
    }

    public static long maxElement(long[] array) {
        return new LongArray(array).max();
    }

    public static int maxPosition(long[] array) {
        return new LongArray(array).maxIndex();
    }

    public static int maxPosition(long[] array, int from, int to) {
        return new LongArray(array).subList(from, to).maxIndex() + from;
    }

    public static int[] createArray(int count, int value) {
        int[] array = new int[count];
        Arrays.fill(array, value);
        return array;
    }

    public static long[] createArray(int count, long value) {
        long[] array = new long[count];
        Arrays.fill(array, value);
        return array;
    }

    public static double[] createArray(int count, double value) {
        double[] array = new double[count];
        Arrays.fill(array, value);
        return array;
    }

    public static boolean[] createArray(int count, boolean value) {
        boolean[] array = new boolean[count];
        Arrays.fill(array, value);
        return array;
    }

    public static char[] createArray(int count, char value) {
        char[] array = new char[count];
        Arrays.fill(array, value);
        return array;
    }

    public static <T> T[] createArray(int count, T value) {
        @SuppressWarnings("unchecked")
        T[] array = (T[]) Array.newInstance(value.getClass(), count);
        Arrays.fill(array, value);
        return array;
    }

    public static long[][] partialSums(int[][] array) {
        int height = array.length;
        int width = array[0].length;
        long[][] result = new long[height + 1][width + 1];
        for (int i = 1; i <= height; i++) {
            for (int j = 1; j <= width; j++) {
                result[i][j] = result[i][j - 1] + result[i - 1][j] - result[i - 1][j - 1] + array[i - 1][j - 1];
            }
        }
        return result;
    }

    public static long[][] partialSums(long[][] array) {
        int height = array.length;
        int width = array[0].length;
        long[][] result = new long[height + 1][width + 1];
        for (int i = 1; i <= height; i++) {
            for (int j = 1; j <= width; j++) {
                result[i][j] = result[i][j - 1] + result[i - 1][j] - result[i - 1][j - 1] + array[i - 1][j - 1];
            }
        }
        return result;
    }

    public static int[][] transpose(int[][] array) {
        if (array.length == 0) {
            return new int[0][0];
        }
        int[][] result = new int[array[0].length][array.length];
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array[i].length; j++) {
                result[j][i] = array[i][j];
            }
        }
        return result;
    }

    public static int find(int[] array, int value) {
        return new IntArray(array).find(value);
    }

    public static int find(char[] array, char value) {
        return new CharArray(array).find(value);
    }

    public static long[] concatenate(long[] arr1, long[] arr2) {
        long[] result = Arrays.copyOf(arr1, arr1.length + arr2.length);
        System.arraycopy(arr2, 0, result, arr1.length, arr2.length);
        return result;
    }

    public static char[] concatenate(char[] arr1, char[] arr2) {
        char[] result = Arrays.copyOf(arr1, arr1.length + arr2.length);
        System.arraycopy(arr2, 0, result, arr1.length, arr2.length);
        return result;
    }

    public static int[] concatenate(int[] arr1, int[] arr2) {
        int[] result = Arrays.copyOf(arr1, arr1.length + arr2.length);
        System.arraycopy(arr2, 0, result, arr1.length, arr2.length);
        return result;
    }
}
/**
 * @author egor@egork.net
 */
 class ExtendedRandom extends Random {
    public ExtendedRandom(long seed) {
        super(seed);
    }

    public int nextInt(int from, int to) {
        return nextInt(to - from) + from;
    }

    public int[] nextIntArray(int size, int from, int to) {
        int[] result = new int[size];
        for (int i = 0; i < size; i++) {
            result[i] = nextInt(from, to);
        }
        return result;
    }

    public char[] nextCharArray(int size, char... letters) {
        char[] result = new char[size];
        for (int i = 0; i < size; i++) {
            result[i] = letters[nextInt(letters.length)];
        }
        return result;
    }
}
/**
 * @author Egor Kulikov (kulikov@devexperts.com)
 */
 interface Factory<V> {
    public V create();
}
/**
 * @author egorku@yandex-team.ru
 */
 abstract class MapVisitor {
    protected final int rowCount;
    protected final int columnCount;
    protected final int[] dRow;
    protected final int[] dColumn;
    protected int[] rowQueue;
    protected int[] columnQueue;
    protected int start, end;

    public MapVisitor(int rowCount, int columnCount) {
        this(rowCount, columnCount, MiscUtils.DX4, MiscUtils.DY4);
    }

    public MapVisitor(int rowCount, int columnCount, int[] dRow, int[] dColumn, int queueCapacity) {
        this.rowCount = rowCount;
        this.columnCount = columnCount;
        this.dRow = dRow;
        this.dColumn = dColumn;
        rowQueue = new int[queueCapacity];
        columnQueue = new int[queueCapacity];
    }

    public MapVisitor(int rowCount, int columnCount, int[] dRow, int[] dColumn) {
        this(rowCount, columnCount, dRow, dColumn, rowCount * columnCount);
    }

    protected abstract void process(int row, int column, int fromRow, int fromColumn);

    public void processAll() {
        for (int i = 0; i < rowCount; i++) {
            for (int j = 0; j < columnCount; j++) {
                process(i, j);
            }
        }
    }

    public void process(int startRow, int startColumn) {
        start = 0;
        end = 0;
        internalProcess(startRow, startColumn, -1, -1);
        while (start != end) {
            int row = rowQueue[start];
            int column = columnQueue[start++];
            if (start == rowQueue.length) {
                start = 0;
            }
            for (int i = 0; i < dRow.length; i++) {
                int nextRow = row + dRow[i];
                int nextColumn = column + dColumn[i];
                if (nextRow >= 0 && nextRow < rowCount && nextColumn >= 0 && nextColumn < columnCount) {
                    internalProcess(nextRow, nextColumn, row, column);
                }
            }
        }
    }

    protected void internalProcess(int row, int column, int fromRow, int fromColumn) {
        process(row, column, fromRow, fromColumn);
    }

    protected void add(int row, int column) {
        rowQueue[end] = row;
        columnQueue[end++] = column;
        if (end == rowQueue.length) {
            end = 0;
        }
    }

    protected void addFront(int row, int column) {
        if (--start == -1) {
            start = rowQueue.length - 1;
        }
        rowQueue[start] = row;
        columnQueue[start] = column;
    }
}
/**
 * @author Egor Kulikov (kulikov@devexperts.com)
 */
 class MiscUtils {
    public static final int[] DX4 = {1, 0, -1, 0};
    public static final int[] DY4 = {0, -1, 0, 1};
    public static final int[] DX8 = {1, 1, 1, 0, -1, -1, -1, 0};
    public static final int[] DY8 = {-1, 0, 1, 1, 1, 0, -1, -1};
    public static final int[] DX_KNIGHT = {2, 1, -1, -2, -2, -1, 1, 2};
    public static final int[] DY_KNIGHT = {1, 2, 2, 1, -1, -2, -2, -1};
    public static final int MOD9 = (int) (1e9 + 9);
    public static final int MOD7 = (int) (1e9 + 7);
    public static final int MODF = 998_244_353;

    private static final String[] ROMAN_TOKENS =
            {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
    private static final int[] ROMAN_VALUES = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};

    public static long josephProblem(long n, int k) {
        if (n == 1) {
            return 0;
        }
        if (k == 1) {
            return n - 1;
        }
        if (k > n) {
            return (josephProblem(n - 1, k) + k) % n;
        }
        long count = n / k;
        long result = josephProblem(n - count, k);
        result -= n % k;
        if (result < 0) {
            result += n;
        } else {
            result += result / (k - 1);
        }
        return result;
    }

    public static boolean isValidCell(int row, int column, int rowCount, int columnCount) {
        return row >= 0 && row < rowCount && column >= 0 && column < columnCount;
    }

    public static IntList getPath(int[] last, int destination) {
        IntList path = new IntArrayList();
        while (destination != -1) {
            path.add(destination);
            destination = last[destination];
        }
        path.inPlaceReverse();
        return path;
    }

    public static IntList getPath(int[][] lastIndex, int[][] lastPathNumber, int destination, int pathNumber) {
        IntList path = new IntArrayList();
        while (destination != -1 || pathNumber != 0) {
            path.add(destination);
            int nextDestination = lastIndex[destination][pathNumber];
            pathNumber = lastPathNumber[destination][pathNumber];
            destination = nextDestination;
        }
        path.inPlaceReverse();
        return path;
    }

    public static long maximalRectangleSum(long[][] array) {
        int n = array.length;
        int m = array[0].length;
        long[][] partialSums = new long[n + 1][m + 1];
        for (int i = 0; i < n; i++) {
            long rowSum = 0;
            for (int j = 0; j < m; j++) {
                rowSum += array[i][j];
                partialSums[i + 1][j + 1] = partialSums[i][j + 1] + rowSum;
            }
        }
        long result = Long.MIN_VALUE;
        for (int i = 0; i < m; i++) {
            for (int j = i; j < m; j++) {
                long minPartialSum = 0;
                for (int k = 1; k <= n; k++) {
                    long current = partialSums[k][j + 1] - partialSums[k][i];
                    result = Math.max(result, current - minPartialSum);
                    minPartialSum = Math.min(minPartialSum, current);
                }
            }
        }
        return result;
    }

    public static int parseIP(String ip) {
        String[] components = ip.split("[.]");
        int result = 0;
        for (int i = 0; i < 4; i++) {
            result += (1 << (24 - 8 * i)) * Integer.parseInt(components[i]);
        }
        return result;
    }

    public static String buildIP(int mask) {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < 4; i++) {
            if (i != 0) {
                result.append('.');
            }
            result.append(mask >> (24 - 8 * i) & 255);
        }
        return result.toString();
    }

    public static long binarySearch(long from, long to, LongFilter function) {
        while (from < to) {
            long argument = from + ((to - from) >> 1);
            if (function.accept(argument)) {
                to = argument;
            } else {
                from = argument + 1;
            }
        }
        return from;
    }

    public static <T> boolean equals(T first, T second) {
        return first == null && second == null || first != null && first.equals(second);
    }

    public static boolean isVowel(char ch) {
        ch = Character.toUpperCase(ch);
        return ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U' || ch == 'Y';
    }

    public static boolean isStrictVowel(char ch) {
        ch = Character.toUpperCase(ch);
        return ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';
    }

    public static String convertToRoman(int number) {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < ROMAN_TOKENS.length; i++) {
            while (number >= ROMAN_VALUES[i]) {
                number -= ROMAN_VALUES[i];
                result.append(ROMAN_TOKENS[i]);
            }
        }
        return result.toString();
    }

    public static int convertFromRoman(String number) {
        int result = 0;
        for (int i = 0; i < ROMAN_TOKENS.length; i++) {
            while (number.startsWith(ROMAN_TOKENS[i])) {
                number = number.substring(ROMAN_TOKENS[i].length());
                result += ROMAN_VALUES[i];
            }
        }
        return result;
    }

    public static int distance(int x1, int y1, int x2, int y2) {
        int dx = x1 - x2;
        int dy = y1 - y2;
        return dx * dx + dy * dy;
    }

    public static <T extends Comparable<T>> T min(T first, T second) {
        if (first.compareTo(second) <= 0) {
            return first;
        }
        return second;
    }

    public static <T extends Comparable<T>> T max(T first, T second) {
        if (first.compareTo(second) <= 0) {
            return second;
        }
        return first;
    }

    public static void decreaseByOne(int[]... arrays) {
        for (int[] array : arrays) {
            for (int i = 0; i < array.length; i++) {
                array[i]--;
            }
        }
    }

    public static int[] getIntArray(String s) {
        String[] tokens = s.split(" ");
        int[] result = new int[tokens.length];
        for (int i = 0; i < result.length; i++) {
            result[i] = Integer.parseInt(tokens[i]);
        }
        return result;
    }
}
/**
 * @author Egor Kulikov (kulikov@devexperts.com)
 */
 interface Operation<V> extends Factory<V> {
    public V operation(V first, V second);
}
/**
 * @author Egor Kulikov (kulikov@devexperts.com)
 */
 interface PowerOperation<V> extends Operation<V> {
    public V power(V base, int exponent);
}
/**
 * @author egorku@yandex-team.ru
 */
 abstract class SimpleMapVisitor extends MapVisitor {
    protected final boolean[][] processed;

    public SimpleMapVisitor(int rowCount, int columnCount) {
        this(rowCount, columnCount, MiscUtils.DX4, MiscUtils.DY4);
    }

    public SimpleMapVisitor(int rowCount, int columnCount, int[] dRow, int[] dColumn) {
        super(rowCount, columnCount, dRow, dColumn);
        processed = new boolean[rowCount][columnCount];
    }

    @Override
    protected void internalProcess(int row, int column, int fromRow, int fromColumn) {
        if (processed[row][column]) {
            return;
        }
        processed[row][column] = true;
        process(row, column, fromRow, fromColumn);
    }
}
class CharArray extends CharAbstractStream implements CharList {
    private char[] data;

    public CharArray(char[] arr) {
        data = arr;
    }

    public int size() {
        return data.length;
    }

    public char get(int at) {
        return data[at];
    }

    public void addAt(int index, char value) {
        throw new UnsupportedOperationException();
    }

    public void removeAt(int index) {
        throw new UnsupportedOperationException();
    }

    public void set(int index, char value) {
        data[index] = value;
    }
}
class CharArrayList extends CharAbstractStream implements CharList {
    private int size;
    private char[] data;

    public CharArrayList() {
        this(3);
    }

    public CharArrayList(int capacity) {
        data = new char[capacity];
    }

    public CharArrayList(CharCollection c) {
        this(c.size());
        addAll(c);
    }

    public CharArrayList(CharStream c) {
        this();
        if (c instanceof CharCollection) {
            ensureCapacity(((CharCollection) c).size());
        }
        addAll(c);
    }

    public CharArrayList(CharArrayList c) {
        size = c.size();
        data = c.data.clone();
    }

    public CharArrayList(char[] arr) {
        size = arr.length;
        data = arr.clone();
    }

    public int size() {
        return size;
    }

    public char get(int at) {
        if (at >= size) {
            throw new IndexOutOfBoundsException("at = " + at + ", size = " + size);
        }
        return data[at];
    }

    private void ensureCapacity(int capacity) {
        if (data.length >= capacity) {
            return;
        }
        capacity = Math.max(2 * data.length, capacity);
        data = Arrays.copyOf(data, capacity);
    }

    public void addAt(int index, char value) {
        ensureCapacity(size + 1);
        if (index > size || index < 0) {
            throw new IndexOutOfBoundsException("at = " + index + ", size = " + size);
        }
        if (index != size) {
            System.arraycopy(data, index, data, index + 1, size - index);
        }
        data[index] = value;
        size++;
    }

    public void removeAt(int index) {
        if (index >= size || index < 0) {
            throw new IndexOutOfBoundsException("at = " + index + ", size = " + size);
        }
        if (index != size - 1) {
            System.arraycopy(data, index + 1, data, index, size - index - 1);
        }
        size--;
    }

    public void set(int index, char value) {
        if (index >= size) {
            throw new IndexOutOfBoundsException("at = " + index + ", size = " + size);
        }
        data[index] = value;
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharList extends CharReversableCollection {
    public static final CharList EMPTY = new CharArray(new char[0]);

    //abstract
    public abstract char get(int index);

    public abstract void set(int index, char value);

    public abstract void addAt(int index, char value);

    public abstract void removeAt(int index);

    //base
    default public char first() {
        return get(0);
    }

    default public char last() {
        return get(size() - 1);
    }

    default public void swap(int first, int second) {
        if (first == second) {
            return;
        }
        char temp = get(first);
        set(first, get(second));
        set(second, temp);
    }

    default public CharIterator charIterator() {
        return new CharIterator() {
            private int at;
            private boolean removed;

            public char value() {
                if (removed) {
                    throw new IllegalStateException();
                }
                return get(at);
            }

            public boolean advance() {
                at++;
                removed = false;
                return isValid();
            }

            public boolean isValid() {
                return !removed && at < size();
            }

            public void remove() {
                removeAt(at);
                at--;
                removed = true;
            }
        };
    }

    default public CharIterator reverseIterator() {
        return new CharIterator() {
            private int at = size() - 1;
            private boolean removed;

            public char value() {
                if (removed) {
                    throw new IllegalStateException();
                }
                return get(at);
            }

            public boolean advance() {
                at--;
                removed = false;
                return isValid();
            }

            public boolean isValid() {
                return !removed && at >= 0;
            }

            public void remove() {
                removeAt(at);
                removed = true;
            }
        };
    }

    @Override
    default public void add(char value) {
        addAt(size(), value);
    }

    default public void popLast() {
        removeAt(size() - 1);
    }

    default public void popFirst() {
        removeAt(0);
    }

    //algorithms
    default public int minIndex() {
        char result = Character.MAX_VALUE;
        int size = size();
        int at = -1;
        for (int i = 0; i < size; i++) {
            char current = get(i);
            if (current < result) {
                result = current;
                at = i;
            }
        }
        return at;
    }

    default public int minIndex(CharComparator comparator) {
        char result = Character.MAX_VALUE;
        int size = size();
        int at = -1;
        for (int i = 0; i < size; i++) {
            char current = get(i);
            if (result == Character.MAX_VALUE || comparator.compare(result, current) > 0) {
                result = current;
                at = i;
            }
        }
        return at;
    }

    default public int maxIndex() {
        char result = Character.MIN_VALUE;
        int size = size();
        int at = -1;
        for (int i = 0; i < size; i++) {
            char current = get(i);
            if (current > result) {
                result = current;
                at = i;
            }
        }
        return at;
    }

    default public int maxIndex(CharComparator comparator) {
        char result = Character.MAX_VALUE;
        int size = size();
        int at = -1;
        for (int i = 0; i < size; i++) {
            char current = get(i);
            if (result == Character.MAX_VALUE || comparator.compare(result, current) < 0) {
                result = current;
                at = i;
            }
        }
        return at;
    }

    default public CharList sort() {
        sort(CharComparator.DEFAULT);
        return this;
    }

    default public CharList sort(CharComparator comparator) {
        Sorter.sort(this, comparator);
        return this;
    }

    default public int find(char value) {
        int size = size();
        for (int i = 0; i < size; i++) {
            if (get(i) == value) {
                return i;
            }
        }
        return -1;
    }

    default public int find(CharFilter filter) {
        int size = size();
        for (int i = 0; i < size; i++) {
            if (filter.accept(get(i))) {
                return i;
            }
        }
        return -1;
    }

    default public int findLast(char value) {
        for (int i = size() - 1; i >= 0; i--) {
            if (get(i) == value) {
                return i;
            }
        }
        return -1;
    }

    default public int findLast(CharFilter filter) {
        for (int i = size() - 1; i >= 0; i--) {
            if (filter.accept(get(i))) {
                return i;
            }
        }
        return -1;
    }

    default public boolean nextPermutation() {
        return nextPermutation(CharComparator.DEFAULT);
    }

    default public boolean nextPermutation(CharComparator comparator) {
        int size = size();
        char last = get(size - 1);
        for (int i = size - 2; i >= 0; i--) {
            char current = get(i);
            if (comparator.compare(last, current) > 0) {
                for (int j = size - 1; j > i; j--) {
                    if (comparator.compare(get(j), current) > 0) {
                        swap(i, j);
                        subList(i + 1, size).inPlaceReverse();
                        return true;
                    }
                }
            }
            last = current;
        }
        return false;
    }

    default public void inPlaceReverse() {
        for (int i = 0, j = size() - 1; i < j; i++, j--) {
            swap(i, j);
        }
    }

    default CharList unique() {
        char last = Character.MAX_VALUE;
        CharList result = new CharArrayList();
        int size = size();
        for (int i = 0; i < size; i++) {
            char current = get(i);
            if (current != last) {
                result.add(current);
                last = current;
            }
        }
        return result;
    }

    default int mismatch(CharList l) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (get(i) != l.get(i)) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default int mismatch(DoubleList l, CharDoublePredicate p) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (!p.value(get(i), l.get(i))) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default int mismatch(IntList l, CharIntPredicate p) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (!p.value(get(i), l.get(i))) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default int mismatch(LongList l, CharLongPredicate p) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (!p.value(get(i), l.get(i))) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default int mismatch(CharList l, CharCharPredicate p) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (!p.value(get(i), l.get(i))) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default CharList fill(char value) {
        int size = size();
        for (int i = 0; i < size; i++) {
            set(i, value);
        }
        return this;
    }

    default CharList fill(IntToCharFunction f) {
        int size = size();
        for (int i = 0; i < size; i++) {
            set(i, f.value(i));
        }
        return this;
    }

    default CharList replace(char sample, char value) {
        int size = size();
        for (int i = 0; i < size; i++) {
            if (get(i) == sample) {
                set(i, value);
            }
        }
        return this;
    }

    default CharList replace(CharFilter f, char value) {
        int size = size();
        for (int i = 0; i < size; i++) {
            if (f.accept(get(i))) {
                set(i, value);
            }
        }
        return this;
    }

    default int binarySearch(CharFilter f) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (f.accept(get(middle))) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    default int moreOrEqual(char value) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (value <= get(middle)) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    default int moreOrEqual(char value, CharComparator c) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (c.compare(value, get(middle)) <= 0) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    default int more(char value) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (value < get(middle)) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    default int more(char value, CharComparator c) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (c.compare(value, get(middle)) < 0) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    //views
    default public CharList subList(final int from, final int to) {
        return new CharList() {
            private final int shift;
            private final int size;

            {
                if (from < 0 || from > to || to > CharList.this.size()) {
                    throw new IndexOutOfBoundsException("from = " + from + ", to = " + to + ", size = " + size());
                }
                shift = from;
                size = to - from;
            }

            public int size() {
                return size;
            }

            public char get(int at) {
                if (at < 0 || at >= size) {
                    throw new IndexOutOfBoundsException("at = " + at + ", size = " + size());
                }
                return CharList.this.get(at + shift);
            }

            public void addAt(int index, char value) {
                throw new UnsupportedOperationException();
            }

            public void removeAt(int index) {
                throw new UnsupportedOperationException();
            }

            public void set(int at, char value) {
                if (at < 0 || at >= size) {
                    throw new IndexOutOfBoundsException("at = " + at + ", size = " + size());
                }
                CharList.this.set(at + shift, value);
            }

            public CharList compute() {
                return new CharArrayList(this);
            }
        };
    }
}
class DoubleArray extends DoubleAbstractStream implements DoubleList {
    private double[] data;

    public DoubleArray(double[] arr) {
        data = arr;
    }

    public int size() {
        return data.length;
    }

    public double get(int at) {
        return data[at];
    }

    public void addAt(int index, double value) {
        throw new UnsupportedOperationException();
    }

    public void removeAt(int index) {
        throw new UnsupportedOperationException();
    }

    public void set(int index, double value) {
        data[index] = value;
    }
}
class DoubleArrayList extends DoubleAbstractStream implements DoubleList {
    private int size;
    private double[] data;

    public DoubleArrayList() {
        this(3);
    }

    public DoubleArrayList(int capacity) {
        data = new double[capacity];
    }

    public DoubleArrayList(DoubleCollection c) {
        this(c.size());
        addAll(c);
    }

    public DoubleArrayList(DoubleStream c) {
        this();
        if (c instanceof DoubleCollection) {
            ensureCapacity(((DoubleCollection) c).size());
        }
        addAll(c);
    }

    public DoubleArrayList(DoubleArrayList c) {
        size = c.size();
        data = c.data.clone();
    }

    public DoubleArrayList(double[] arr) {
        size = arr.length;
        data = arr.clone();
    }

    public int size() {
        return size;
    }

    public double get(int at) {
        if (at >= size) {
            throw new IndexOutOfBoundsException("at = " + at + ", size = " + size);
        }
        return data[at];
    }

    private void ensureCapacity(int capacity) {
        if (data.length >= capacity) {
            return;
        }
        capacity = Math.max(2 * data.length, capacity);
        data = Arrays.copyOf(data, capacity);
    }

    public void addAt(int index, double value) {
        ensureCapacity(size + 1);
        if (index > size || index < 0) {
            throw new IndexOutOfBoundsException("at = " + index + ", size = " + size);
        }
        if (index != size) {
            System.arraycopy(data, index, data, index + 1, size - index);
        }
        data[index] = value;
        size++;
    }

    public void removeAt(int index) {
        if (index >= size || index < 0) {
            throw new IndexOutOfBoundsException("at = " + index + ", size = " + size);
        }
        if (index != size - 1) {
            System.arraycopy(data, index + 1, data, index, size - index - 1);
        }
        size--;
    }

    public void set(int index, double value) {
        if (index >= size) {
            throw new IndexOutOfBoundsException("at = " + index + ", size = " + size);
        }
        data[index] = value;
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleList extends DoubleReversableCollection {
    public static final DoubleList EMPTY = new DoubleArray(new double[0]);

    //abstract
    public abstract double get(int index);

    public abstract void set(int index, double value);

    public abstract void addAt(int index, double value);

    public abstract void removeAt(int index);

    //base
    default public double first() {
        return get(0);
    }

    default public double last() {
        return get(size() - 1);
    }

    default public void swap(int first, int second) {
        if (first == second) {
            return;
        }
        double temp = get(first);
        set(first, get(second));
        set(second, temp);
    }

    default public DoubleIterator doubleIterator() {
        return new DoubleIterator() {
            private int at;
            private boolean removed;

            public double value() {
                if (removed) {
                    throw new IllegalStateException();
                }
                return get(at);
            }

            public boolean advance() {
                at++;
                removed = false;
                return isValid();
            }

            public boolean isValid() {
                return !removed && at < size();
            }

            public void remove() {
                removeAt(at);
                at--;
                removed = true;
            }
        };
    }

    default public DoubleIterator reverseIterator() {
        return new DoubleIterator() {
            private int at = size() - 1;
            private boolean removed;

            public double value() {
                if (removed) {
                    throw new IllegalStateException();
                }
                return get(at);
            }

            public boolean advance() {
                at--;
                removed = false;
                return isValid();
            }

            public boolean isValid() {
                return !removed && at >= 0;
            }

            public void remove() {
                removeAt(at);
                removed = true;
            }
        };
    }

    @Override
    default public void add(double value) {
        addAt(size(), value);
    }

    default public void popLast() {
        removeAt(size() - 1);
    }

    default public void popFirst() {
        removeAt(0);
    }

    //algorithms
    default public int minIndex() {
        double result = Double.POSITIVE_INFINITY;
        int size = size();
        int at = -1;
        for (int i = 0; i < size; i++) {
            double current = get(i);
            if (current < result) {
                result = current;
                at = i;
            }
        }
        return at;
    }

    default public int minIndex(DoubleComparator comparator) {
        double result = Double.MIN_NORMAL;
        int size = size();
        int at = -1;
        for (int i = 0; i < size; i++) {
            double current = get(i);
            if (result == Double.MIN_NORMAL || comparator.compare(result, current) > 0) {
                result = current;
                at = i;
            }
        }
        return at;
    }

    default public int maxIndex() {
        double result = Double.NEGATIVE_INFINITY;
        int size = size();
        int at = -1;
        for (int i = 0; i < size; i++) {
            double current = get(i);
            if (current > result) {
                result = current;
                at = i;
            }
        }
        return at;
    }

    default public int maxIndex(DoubleComparator comparator) {
        double result = Double.MIN_NORMAL;
        int size = size();
        int at = -1;
        for (int i = 0; i < size; i++) {
            double current = get(i);
            if (result == Double.MIN_NORMAL || comparator.compare(result, current) < 0) {
                result = current;
                at = i;
            }
        }
        return at;
    }

    default public DoubleList sort() {
        sort(DoubleComparator.DEFAULT);
        return this;
    }

    default public DoubleList sort(DoubleComparator comparator) {
        Sorter.sort(this, comparator);
        return this;
    }

    default public int find(double value) {
        int size = size();
        for (int i = 0; i < size; i++) {
            if (get(i) == value) {
                return i;
            }
        }
        return -1;
    }

    default public int find(DoubleFilter filter) {
        int size = size();
        for (int i = 0; i < size; i++) {
            if (filter.accept(get(i))) {
                return i;
            }
        }
        return -1;
    }

    default public int findLast(double value) {
        for (int i = size() - 1; i >= 0; i--) {
            if (get(i) == value) {
                return i;
            }
        }
        return -1;
    }

    default public int findLast(DoubleFilter filter) {
        for (int i = size() - 1; i >= 0; i--) {
            if (filter.accept(get(i))) {
                return i;
            }
        }
        return -1;
    }

    default public boolean nextPermutation() {
        return nextPermutation(DoubleComparator.DEFAULT);
    }

    default public boolean nextPermutation(DoubleComparator comparator) {
        int size = size();
        double last = get(size - 1);
        for (int i = size - 2; i >= 0; i--) {
            double current = get(i);
            if (comparator.compare(last, current) > 0) {
                for (int j = size - 1; j > i; j--) {
                    if (comparator.compare(get(j), current) > 0) {
                        swap(i, j);
                        subList(i + 1, size).inPlaceReverse();
                        return true;
                    }
                }
            }
            last = current;
        }
        return false;
    }

    default public void inPlaceReverse() {
        for (int i = 0, j = size() - 1; i < j; i++, j--) {
            swap(i, j);
        }
    }

    default DoubleList unique() {
        double last = Double.MIN_NORMAL;
        DoubleList result = new DoubleArrayList();
        int size = size();
        for (int i = 0; i < size; i++) {
            double current = get(i);
            if (current != last) {
                result.add(current);
                last = current;
            }
        }
        return result;
    }

    default int mismatch(DoubleList l) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (get(i) != l.get(i)) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default int mismatch(DoubleList l, DoubleDoublePredicate p) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (!p.value(get(i), l.get(i))) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default int mismatch(IntList l, DoubleIntPredicate p) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (!p.value(get(i), l.get(i))) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default int mismatch(LongList l, DoubleLongPredicate p) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (!p.value(get(i), l.get(i))) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default int mismatch(CharList l, DoubleCharPredicate p) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (!p.value(get(i), l.get(i))) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default DoubleList fill(double value) {
        int size = size();
        for (int i = 0; i < size; i++) {
            set(i, value);
        }
        return this;
    }

    default DoubleList fill(IntToDoubleFunction f) {
        int size = size();
        for (int i = 0; i < size; i++) {
            set(i, f.value(i));
        }
        return this;
    }

    default DoubleList replace(double sample, double value) {
        int size = size();
        for (int i = 0; i < size; i++) {
            if (get(i) == sample) {
                set(i, value);
            }
        }
        return this;
    }

    default DoubleList replace(DoubleFilter f, double value) {
        int size = size();
        for (int i = 0; i < size; i++) {
            if (f.accept(get(i))) {
                set(i, value);
            }
        }
        return this;
    }

    default int binarySearch(DoubleFilter f) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (f.accept(get(middle))) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    default int moreOrEqual(double value) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (value <= get(middle)) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    default int moreOrEqual(double value, DoubleComparator c) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (c.compare(value, get(middle)) <= 0) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    default int more(double value) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (value < get(middle)) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    default int more(double value, DoubleComparator c) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (c.compare(value, get(middle)) < 0) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    //views
    default public DoubleList subList(final int from, final int to) {
        return new DoubleList() {
            private final int shift;
            private final int size;

            {
                if (from < 0 || from > to || to > DoubleList.this.size()) {
                    throw new IndexOutOfBoundsException("from = " + from + ", to = " + to + ", size = " + size());
                }
                shift = from;
                size = to - from;
            }

            public int size() {
                return size;
            }

            public double get(int at) {
                if (at < 0 || at >= size) {
                    throw new IndexOutOfBoundsException("at = " + at + ", size = " + size());
                }
                return DoubleList.this.get(at + shift);
            }

            public void addAt(int index, double value) {
                throw new UnsupportedOperationException();
            }

            public void removeAt(int index) {
                throw new UnsupportedOperationException();
            }

            public void set(int at, double value) {
                if (at < 0 || at >= size) {
                    throw new IndexOutOfBoundsException("at = " + at + ", size = " + size());
                }
                DoubleList.this.set(at + shift, value);
            }

            public DoubleList compute() {
                return new DoubleArrayList(this);
            }
        };
    }
}
class IntArray extends IntAbstractStream implements IntList {
    private int[] data;

    public IntArray(int[] arr) {
        data = arr;
    }

    public int size() {
        return data.length;
    }

    public int get(int at) {
        return data[at];
    }

    public void addAt(int index, int value) {
        throw new UnsupportedOperationException();
    }

    public void removeAt(int index) {
        throw new UnsupportedOperationException();
    }

    public void set(int index, int value) {
        data[index] = value;
    }
}
class IntArrayList extends IntAbstractStream implements IntList {
    private int size;
    private int[] data;

    public IntArrayList() {
        this(3);
    }

    public IntArrayList(int capacity) {
        data = new int[capacity];
    }

    public IntArrayList(IntCollection c) {
        this(c.size());
        addAll(c);
    }

    public IntArrayList(IntStream c) {
        this();
        if (c instanceof IntCollection) {
            ensureCapacity(((IntCollection) c).size());
        }
        addAll(c);
    }

    public IntArrayList(IntArrayList c) {
        size = c.size();
        data = c.data.clone();
    }

    public IntArrayList(int[] arr) {
        size = arr.length;
        data = arr.clone();
    }

    public int size() {
        return size;
    }

    public int get(int at) {
        if (at >= size) {
            throw new IndexOutOfBoundsException("at = " + at + ", size = " + size);
        }
        return data[at];
    }

    private void ensureCapacity(int capacity) {
        if (data.length >= capacity) {
            return;
        }
        capacity = Math.max(2 * data.length, capacity);
        data = Arrays.copyOf(data, capacity);
    }

    public void addAt(int index, int value) {
        ensureCapacity(size + 1);
        if (index > size || index < 0) {
            throw new IndexOutOfBoundsException("at = " + index + ", size = " + size);
        }
        if (index != size) {
            System.arraycopy(data, index, data, index + 1, size - index);
        }
        data[index] = value;
        size++;
    }

    public void removeAt(int index) {
        if (index >= size || index < 0) {
            throw new IndexOutOfBoundsException("at = " + index + ", size = " + size);
        }
        if (index != size - 1) {
            System.arraycopy(data, index + 1, data, index, size - index - 1);
        }
        size--;
    }

    public void set(int index, int value) {
        if (index >= size) {
            throw new IndexOutOfBoundsException("at = " + index + ", size = " + size);
        }
        data[index] = value;
    }

    @Override
    public int[] toArray() {
        return Arrays.copyOf(data, size);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntList extends IntReversableCollection {
    public static final IntList EMPTY = new IntArray(new int[0]);

    //abstract
    public abstract int get(int index);

    public abstract void set(int index, int value);

    public abstract void addAt(int index, int value);

    public abstract void removeAt(int index);

    //base
    default public int first() {
        return get(0);
    }

    default public int last() {
        return get(size() - 1);
    }

    default public void swap(int first, int second) {
        if (first == second) {
            return;
        }
        int temp = get(first);
        set(first, get(second));
        set(second, temp);
    }

    default public IntIterator intIterator() {
        return new IntIterator() {
            private int at;
            private boolean removed;

            public int value() {
                if (removed) {
                    throw new IllegalStateException();
                }
                return get(at);
            }

            public boolean advance() {
                at++;
                removed = false;
                return isValid();
            }

            public boolean isValid() {
                return !removed && at < size();
            }

            public void remove() {
                removeAt(at);
                at--;
                removed = true;
            }
        };
    }

    default public IntIterator reverseIterator() {
        return new IntIterator() {
            private int at = size() - 1;
            private boolean removed;

            public int value() {
                if (removed) {
                    throw new IllegalStateException();
                }
                return get(at);
            }

            public boolean advance() {
                at--;
                removed = false;
                return isValid();
            }

            public boolean isValid() {
                return !removed && at >= 0;
            }

            public void remove() {
                removeAt(at);
                removed = true;
            }
        };
    }

    @Override
    default public void add(int value) {
        addAt(size(), value);
    }

    default public void popLast() {
        removeAt(size() - 1);
    }

    default public void popFirst() {
        removeAt(0);
    }

    //algorithms
    default public int minIndex() {
        int result = Integer.MAX_VALUE;
        int size = size();
        int at = -1;
        for (int i = 0; i < size; i++) {
            int current = get(i);
            if (current < result) {
                result = current;
                at = i;
            }
        }
        return at;
    }

    default public int minIndex(IntComparator comparator) {
        int result = Integer.MIN_VALUE;
        int size = size();
        int at = -1;
        for (int i = 0; i < size; i++) {
            int current = get(i);
            if (result == Integer.MIN_VALUE || comparator.compare(result, current) > 0) {
                result = current;
                at = i;
            }
        }
        return at;
    }

    default public int maxIndex() {
        int result = Integer.MIN_VALUE;
        int size = size();
        int at = -1;
        for (int i = 0; i < size; i++) {
            int current = get(i);
            if (current > result) {
                result = current;
                at = i;
            }
        }
        return at;
    }

    default public int maxIndex(IntComparator comparator) {
        int result = Integer.MIN_VALUE;
        int size = size();
        int at = -1;
        for (int i = 0; i < size; i++) {
            int current = get(i);
            if (result == Integer.MIN_VALUE || comparator.compare(result, current) < 0) {
                result = current;
                at = i;
            }
        }
        return at;
    }

    default public IntList sort() {
        sort(IntComparator.DEFAULT);
        return this;
    }

    default public IntList sort(IntComparator comparator) {
        Sorter.sort(this, comparator);
        return this;
    }

    default public int find(int value) {
        int size = size();
        for (int i = 0; i < size; i++) {
            if (get(i) == value) {
                return i;
            }
        }
        return -1;
    }

    default public int find(IntFilter filter) {
        int size = size();
        for (int i = 0; i < size; i++) {
            if (filter.accept(get(i))) {
                return i;
            }
        }
        return -1;
    }

    default public int findLast(int value) {
        for (int i = size() - 1; i >= 0; i--) {
            if (get(i) == value) {
                return i;
            }
        }
        return -1;
    }

    default public int findLast(IntFilter filter) {
        for (int i = size() - 1; i >= 0; i--) {
            if (filter.accept(get(i))) {
                return i;
            }
        }
        return -1;
    }

    default public boolean nextPermutation() {
        return nextPermutation(IntComparator.DEFAULT);
    }

    default public boolean nextPermutation(IntComparator comparator) {
        int size = size();
        int last = get(size - 1);
        for (int i = size - 2; i >= 0; i--) {
            int current = get(i);
            if (comparator.compare(last, current) > 0) {
                for (int j = size - 1; j > i; j--) {
                    if (comparator.compare(get(j), current) > 0) {
                        swap(i, j);
                        subList(i + 1, size).inPlaceReverse();
                        return true;
                    }
                }
            }
            last = current;
        }
        return false;
    }

    default public void inPlaceReverse() {
        for (int i = 0, j = size() - 1; i < j; i++, j--) {
            swap(i, j);
        }
    }

    default IntList unique() {
        int last = Integer.MIN_VALUE;
        IntList result = new IntArrayList();
        int size = size();
        for (int i = 0; i < size; i++) {
            int current = get(i);
            if (current != last) {
                result.add(current);
                last = current;
            }
        }
        return result;
    }

    default int mismatch(IntList l) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (get(i) != l.get(i)) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default int mismatch(DoubleList l, IntDoublePredicate p) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (!p.value(get(i), l.get(i))) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default int mismatch(IntList l, IntIntPredicate p) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (!p.value(get(i), l.get(i))) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default int mismatch(LongList l, IntLongPredicate p) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (!p.value(get(i), l.get(i))) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default int mismatch(CharList l, IntCharPredicate p) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (!p.value(get(i), l.get(i))) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default IntList fill(int value) {
        int size = size();
        for (int i = 0; i < size; i++) {
            set(i, value);
        }
        return this;
    }

    default IntList fill(IntToIntFunction f) {
        int size = size();
        for (int i = 0; i < size; i++) {
            set(i, f.value(i));
        }
        return this;
    }

    default IntList replace(int sample, int value) {
        int size = size();
        for (int i = 0; i < size; i++) {
            if (get(i) == sample) {
                set(i, value);
            }
        }
        return this;
    }

    default IntList replace(IntFilter f, int value) {
        int size = size();
        for (int i = 0; i < size; i++) {
            if (f.accept(get(i))) {
                set(i, value);
            }
        }
        return this;
    }

    default int binarySearch(IntFilter f) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (f.accept(get(middle))) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    default int moreOrEqual(int value) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (value <= get(middle)) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    default int moreOrEqual(int value, IntComparator c) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (c.compare(value, get(middle)) <= 0) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    default int more(int value) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (value < get(middle)) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    default int more(int value, IntComparator c) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (c.compare(value, get(middle)) < 0) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    //views
    default public IntList subList(final int from, final int to) {
        return new IntList() {
            private final int shift;
            private final int size;

            {
                if (from < 0 || from > to || to > IntList.this.size()) {
                    throw new IndexOutOfBoundsException("from = " + from + ", to = " + to + ", size = " + size());
                }
                shift = from;
                size = to - from;
            }

            public int size() {
                return size;
            }

            public int get(int at) {
                if (at < 0 || at >= size) {
                    throw new IndexOutOfBoundsException("at = " + at + ", size = " + size());
                }
                return IntList.this.get(at + shift);
            }

            public void addAt(int index, int value) {
                throw new UnsupportedOperationException();
            }

            public void removeAt(int index) {
                throw new UnsupportedOperationException();
            }

            public void set(int at, int value) {
                if (at < 0 || at >= size) {
                    throw new IndexOutOfBoundsException("at = " + at + ", size = " + size());
                }
                IntList.this.set(at + shift, value);
            }

            public IntList compute() {
                return new IntArrayList(this);
            }
        };
    }
}
class LongArray extends LongAbstractStream implements LongList {
    private long[] data;

    public LongArray(long[] arr) {
        data = arr;
    }

    public int size() {
        return data.length;
    }

    public long get(int at) {
        return data[at];
    }

    public void addAt(int index, long value) {
        throw new UnsupportedOperationException();
    }

    public void removeAt(int index) {
        throw new UnsupportedOperationException();
    }

    public void set(int index, long value) {
        data[index] = value;
    }
}
class LongArrayList extends LongAbstractStream implements LongList {
    private int size;
    private long[] data;

    public LongArrayList() {
        this(3);
    }

    public LongArrayList(int capacity) {
        data = new long[capacity];
    }

    public LongArrayList(LongCollection c) {
        this(c.size());
        addAll(c);
    }

    public LongArrayList(LongStream c) {
        this();
        if (c instanceof LongCollection) {
            ensureCapacity(((LongCollection) c).size());
        }
        addAll(c);
    }

    public LongArrayList(LongArrayList c) {
        size = c.size();
        data = c.data.clone();
    }

    public LongArrayList(long[] arr) {
        size = arr.length;
        data = arr.clone();
    }

    public int size() {
        return size;
    }

    public long get(int at) {
        if (at >= size) {
            throw new IndexOutOfBoundsException("at = " + at + ", size = " + size);
        }
        return data[at];
    }

    private void ensureCapacity(int capacity) {
        if (data.length >= capacity) {
            return;
        }
        capacity = Math.max(2 * data.length, capacity);
        data = Arrays.copyOf(data, capacity);
    }

    public void addAt(int index, long value) {
        ensureCapacity(size + 1);
        if (index > size || index < 0) {
            throw new IndexOutOfBoundsException("at = " + index + ", size = " + size);
        }
        if (index != size) {
            System.arraycopy(data, index, data, index + 1, size - index);
        }
        data[index] = value;
        size++;
    }

    public void removeAt(int index) {
        if (index >= size || index < 0) {
            throw new IndexOutOfBoundsException("at = " + index + ", size = " + size);
        }
        if (index != size - 1) {
            System.arraycopy(data, index + 1, data, index, size - index - 1);
        }
        size--;
    }

    public void set(int index, long value) {
        if (index >= size) {
            throw new IndexOutOfBoundsException("at = " + index + ", size = " + size);
        }
        data[index] = value;
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongList extends LongReversableCollection {
    public static final LongList EMPTY = new LongArray(new long[0]);

    //abstract
    public abstract long get(int index);

    public abstract void set(int index, long value);

    public abstract void addAt(int index, long value);

    public abstract void removeAt(int index);

    //base
    default public long first() {
        return get(0);
    }

    default public long last() {
        return get(size() - 1);
    }

    default public void swap(int first, int second) {
        if (first == second) {
            return;
        }
        long temp = get(first);
        set(first, get(second));
        set(second, temp);
    }

    default public LongIterator longIterator() {
        return new LongIterator() {
            private int at;
            private boolean removed;

            public long value() {
                if (removed) {
                    throw new IllegalStateException();
                }
                return get(at);
            }

            public boolean advance() {
                at++;
                removed = false;
                return isValid();
            }

            public boolean isValid() {
                return !removed && at < size();
            }

            public void remove() {
                removeAt(at);
                at--;
                removed = true;
            }
        };
    }

    default public LongIterator reverseIterator() {
        return new LongIterator() {
            private int at = size() - 1;
            private boolean removed;

            public long value() {
                if (removed) {
                    throw new IllegalStateException();
                }
                return get(at);
            }

            public boolean advance() {
                at--;
                removed = false;
                return isValid();
            }

            public boolean isValid() {
                return !removed && at >= 0;
            }

            public void remove() {
                removeAt(at);
                removed = true;
            }
        };
    }

    @Override
    default public void add(long value) {
        addAt(size(), value);
    }

    default public void popLast() {
        removeAt(size() - 1);
    }

    default public void popFirst() {
        removeAt(0);
    }

    //algorithms
    default public int minIndex() {
        long result = Long.MAX_VALUE;
        int size = size();
        int at = -1;
        for (int i = 0; i < size; i++) {
            long current = get(i);
            if (current < result) {
                result = current;
                at = i;
            }
        }
        return at;
    }

    default public int minIndex(LongComparator comparator) {
        long result = Long.MIN_VALUE;
        int size = size();
        int at = -1;
        for (int i = 0; i < size; i++) {
            long current = get(i);
            if (result == Long.MIN_VALUE || comparator.compare(result, current) > 0) {
                result = current;
                at = i;
            }
        }
        return at;
    }

    default public int maxIndex() {
        long result = Long.MIN_VALUE;
        int size = size();
        int at = -1;
        for (int i = 0; i < size; i++) {
            long current = get(i);
            if (current > result) {
                result = current;
                at = i;
            }
        }
        return at;
    }

    default public int maxIndex(LongComparator comparator) {
        long result = Long.MIN_VALUE;
        int size = size();
        int at = -1;
        for (int i = 0; i < size; i++) {
            long current = get(i);
            if (result == Long.MIN_VALUE || comparator.compare(result, current) < 0) {
                result = current;
                at = i;
            }
        }
        return at;
    }

    default public LongList sort() {
        sort(LongComparator.DEFAULT);
        return this;
    }

    default public LongList sort(LongComparator comparator) {
        Sorter.sort(this, comparator);
        return this;
    }

    default public int find(long value) {
        int size = size();
        for (int i = 0; i < size; i++) {
            if (get(i) == value) {
                return i;
            }
        }
        return -1;
    }

    default public int find(LongFilter filter) {
        int size = size();
        for (int i = 0; i < size; i++) {
            if (filter.accept(get(i))) {
                return i;
            }
        }
        return -1;
    }

    default public int findLast(long value) {
        for (int i = size() - 1; i >= 0; i--) {
            if (get(i) == value) {
                return i;
            }
        }
        return -1;
    }

    default public int findLast(LongFilter filter) {
        for (int i = size() - 1; i >= 0; i--) {
            if (filter.accept(get(i))) {
                return i;
            }
        }
        return -1;
    }

    default public boolean nextPermutation() {
        return nextPermutation(LongComparator.DEFAULT);
    }

    default public boolean nextPermutation(LongComparator comparator) {
        int size = size();
        long last = get(size - 1);
        for (int i = size - 2; i >= 0; i--) {
            long current = get(i);
            if (comparator.compare(last, current) > 0) {
                for (int j = size - 1; j > i; j--) {
                    if (comparator.compare(get(j), current) > 0) {
                        swap(i, j);
                        subList(i + 1, size).inPlaceReverse();
                        return true;
                    }
                }
            }
            last = current;
        }
        return false;
    }

    default public void inPlaceReverse() {
        for (int i = 0, j = size() - 1; i < j; i++, j--) {
            swap(i, j);
        }
    }

    default LongList unique() {
        long last = Long.MIN_VALUE;
        LongList result = new LongArrayList();
        int size = size();
        for (int i = 0; i < size; i++) {
            long current = get(i);
            if (current != last) {
                result.add(current);
                last = current;
            }
        }
        return result;
    }

    default int mismatch(LongList l) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (get(i) != l.get(i)) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default int mismatch(DoubleList l, LongDoublePredicate p) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (!p.value(get(i), l.get(i))) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default int mismatch(IntList l, LongIntPredicate p) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (!p.value(get(i), l.get(i))) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default int mismatch(LongList l, LongLongPredicate p) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (!p.value(get(i), l.get(i))) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default int mismatch(CharList l, LongCharPredicate p) {
        int size = Math.min(size(), l.size());
        for (int i = 0; i < size; i++) {
            if (!p.value(get(i), l.get(i))) {
                return i;
            }
        }
        if (size() != l.size()) {
            return size;
        }
        return -1;
    }

    default LongList fill(long value) {
        int size = size();
        for (int i = 0; i < size; i++) {
            set(i, value);
        }
        return this;
    }

    default LongList fill(IntToLongFunction f) {
        int size = size();
        for (int i = 0; i < size; i++) {
            set(i, f.value(i));
        }
        return this;
    }

    default LongList replace(long sample, long value) {
        int size = size();
        for (int i = 0; i < size; i++) {
            if (get(i) == sample) {
                set(i, value);
            }
        }
        return this;
    }

    default LongList replace(LongFilter f, long value) {
        int size = size();
        for (int i = 0; i < size; i++) {
            if (f.accept(get(i))) {
                set(i, value);
            }
        }
        return this;
    }

    default int binarySearch(LongFilter f) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (f.accept(get(middle))) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    default int moreOrEqual(long value) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (value <= get(middle)) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    default int moreOrEqual(long value, LongComparator c) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (c.compare(value, get(middle)) <= 0) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    default int more(long value) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (value < get(middle)) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    default int more(long value, LongComparator c) {
        int left = 0;
        int right = size();
        while (left < right) {
            int middle = (left + right) >> 1;
            if (c.compare(value, get(middle)) < 0) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        return left;
    }

    //views
    default public LongList subList(final int from, final int to) {
        return new LongList() {
            private final int shift;
            private final int size;

            {
                if (from < 0 || from > to || to > LongList.this.size()) {
                    throw new IndexOutOfBoundsException("from = " + from + ", to = " + to + ", size = " + size());
                }
                shift = from;
                size = to - from;
            }

            public int size() {
                return size;
            }

            public long get(int at) {
                if (at < 0 || at >= size) {
                    throw new IndexOutOfBoundsException("at = " + at + ", size = " + size());
                }
                return LongList.this.get(at + shift);
            }

            public void addAt(int index, long value) {
                throw new UnsupportedOperationException();
            }

            public void removeAt(int index) {
                throw new UnsupportedOperationException();
            }

            public void set(int at, long value) {
                if (at < 0 || at >= size) {
                    throw new IndexOutOfBoundsException("at = " + at + ", size = " + size());
                }
                LongList.this.set(at + shift, value);
            }

            public LongList compute() {
                return new LongArrayList(this);
            }
        };
    }
}
class Sorter {
    private static final int INSERTION_THRESHOLD = 16;

    private Sorter() {
    }

    public static void sort(DoubleList list, DoubleComparator comparator) {
        quickSort(list, 0, list.size() - 1, (Integer.bitCount(Integer.highestOneBit(list.size()) - 1) * 5) >> 1,
                comparator);
    }

    private static void quickSort(DoubleList list, int from, int to, int remaining, DoubleComparator comparator) {
        if (to - from < INSERTION_THRESHOLD) {
            insertionSort(list, from, to, comparator);
            return;
        }
        if (remaining == 0) {
            heapSort(list, from, to, comparator);
            return;
        }
        remaining--;
        int pivotIndex = (from + to) >> 1;
        double pivot = list.get(pivotIndex);
        list.swap(pivotIndex, to);
        int storeIndex = from;
        int equalIndex = to;
        for (int i = from; i < equalIndex; i++) {
            int value = comparator.compare(list.get(i), pivot);
            if (value < 0) {
                list.swap(storeIndex++, i);
            } else if (value == 0) {
                list.swap(--equalIndex, i--);
            }
        }
        quickSort(list, from, storeIndex - 1, remaining, comparator);
        for (int i = equalIndex; i <= to; i++) {
            list.swap(storeIndex++, i);
        }
        quickSort(list, storeIndex, to, remaining, comparator);
    }

    private static void heapSort(DoubleList list, int from, int to, DoubleComparator comparator) {
        for (int i = (to + from - 1) >> 1; i >= from; i--) {
            siftDown(list, i, to, comparator, from);
        }
        for (int i = to; i > from; i--) {
            list.swap(from, i);
            siftDown(list, from, i - 1, comparator, from);
        }
    }

    private static void siftDown(DoubleList list, int start, int end, DoubleComparator comparator, int delta) {
        double value = list.get(start);
        while (true) {
            int child = ((start - delta) << 1) + 1 + delta;
            if (child > end) {
                return;
            }
            double childValue = list.get(child);
            if (child + 1 <= end) {
                double otherValue = list.get(child + 1);
                if (comparator.compare(otherValue, childValue) > 0) {
                    child++;
                    childValue = otherValue;
                }
            }
            if (comparator.compare(value, childValue) >= 0) {
                return;
            }
            list.swap(start, child);
            start = child;
        }
    }

    private static void insertionSort(DoubleList list, int from, int to, DoubleComparator comparator) {
        for (int i = from + 1; i <= to; i++) {
            double value = list.get(i);
            for (int j = i - 1; j >= from; j--) {
                if (comparator.compare(list.get(j), value) <= 0) {
                    break;
                }
                list.swap(j, j + 1);
            }
        }
    }

    public static void sort(IntList list, IntComparator comparator) {
        quickSort(list, 0, list.size() - 1, (Integer.bitCount(Integer.highestOneBit(list.size()) - 1) * 5) >> 1,
                comparator);
    }

    private static void quickSort(IntList list, int from, int to, int remaining, IntComparator comparator) {
        if (to - from < INSERTION_THRESHOLD) {
            insertionSort(list, from, to, comparator);
            return;
        }
        if (remaining == 0) {
            heapSort(list, from, to, comparator);
            return;
        }
        remaining--;
        int pivotIndex = (from + to) >> 1;
        int pivot = list.get(pivotIndex);
        list.swap(pivotIndex, to);
        int storeIndex = from;
        int equalIndex = to;
        for (int i = from; i < equalIndex; i++) {
            int value = comparator.compare(list.get(i), pivot);
            if (value < 0) {
                list.swap(storeIndex++, i);
            } else if (value == 0) {
                list.swap(--equalIndex, i--);
            }
        }
        quickSort(list, from, storeIndex - 1, remaining, comparator);
        for (int i = equalIndex; i <= to; i++) {
            list.swap(storeIndex++, i);
        }
        quickSort(list, storeIndex, to, remaining, comparator);
    }

    private static void heapSort(IntList list, int from, int to, IntComparator comparator) {
        for (int i = (to + from - 1) >> 1; i >= from; i--) {
            siftDown(list, i, to, comparator, from);
        }
        for (int i = to; i > from; i--) {
            list.swap(from, i);
            siftDown(list, from, i - 1, comparator, from);
        }
    }

    private static void siftDown(IntList list, int start, int end, IntComparator comparator, int delta) {
        int value = list.get(start);
        while (true) {
            int child = ((start - delta) << 1) + 1 + delta;
            if (child > end) {
                return;
            }
            int childValue = list.get(child);
            if (child + 1 <= end) {
                int otherValue = list.get(child + 1);
                if (comparator.compare(otherValue, childValue) > 0) {
                    child++;
                    childValue = otherValue;
                }
            }
            if (comparator.compare(value, childValue) >= 0) {
                return;
            }
            list.swap(start, child);
            start = child;
        }
    }

    private static void insertionSort(IntList list, int from, int to, IntComparator comparator) {
        for (int i = from + 1; i <= to; i++) {
            int value = list.get(i);
            for (int j = i - 1; j >= from; j--) {
                if (comparator.compare(list.get(j), value) <= 0) {
                    break;
                }
                list.swap(j, j + 1);
            }
        }
    }

    public static void sort(LongList list, LongComparator comparator) {
        quickSort(list, 0, list.size() - 1, (Integer.bitCount(Integer.highestOneBit(list.size()) - 1) * 5) >> 1,
                comparator);
    }

    private static void quickSort(LongList list, int from, int to, int remaining, LongComparator comparator) {
        if (to - from < INSERTION_THRESHOLD) {
            insertionSort(list, from, to, comparator);
            return;
        }
        if (remaining == 0) {
            heapSort(list, from, to, comparator);
            return;
        }
        remaining--;
        int pivotIndex = (from + to) >> 1;
        long pivot = list.get(pivotIndex);
        list.swap(pivotIndex, to);
        int storeIndex = from;
        int equalIndex = to;
        for (int i = from; i < equalIndex; i++) {
            int value = comparator.compare(list.get(i), pivot);
            if (value < 0) {
                list.swap(storeIndex++, i);
            } else if (value == 0) {
                list.swap(--equalIndex, i--);
            }
        }
        quickSort(list, from, storeIndex - 1, remaining, comparator);
        for (int i = equalIndex; i <= to; i++) {
            list.swap(storeIndex++, i);
        }
        quickSort(list, storeIndex, to, remaining, comparator);
    }

    private static void heapSort(LongList list, int from, int to, LongComparator comparator) {
        for (int i = (to + from - 1) >> 1; i >= from; i--) {
            siftDown(list, i, to, comparator, from);
        }
        for (int i = to; i > from; i--) {
            list.swap(from, i);
            siftDown(list, from, i - 1, comparator, from);
        }
    }

    private static void siftDown(LongList list, int start, int end, LongComparator comparator, int delta) {
        long value = list.get(start);
        while (true) {
            int child = ((start - delta) << 1) + 1 + delta;
            if (child > end) {
                return;
            }
            long childValue = list.get(child);
            if (child + 1 <= end) {
                long otherValue = list.get(child + 1);
                if (comparator.compare(otherValue, childValue) > 0) {
                    child++;
                    childValue = otherValue;
                }
            }
            if (comparator.compare(value, childValue) >= 0) {
                return;
            }
            list.swap(start, child);
            start = child;
        }
    }

    private static void insertionSort(LongList list, int from, int to, LongComparator comparator) {
        for (int i = from + 1; i <= to; i++) {
            long value = list.get(i);
            for (int j = i - 1; j >= from; j--) {
                if (comparator.compare(list.get(j), value) <= 0) {
                    break;
                }
                list.swap(j, j + 1);
            }
        }
    }

    public static void sort(CharList list, CharComparator comparator) {
        quickSort(list, 0, list.size() - 1, (Integer.bitCount(Integer.highestOneBit(list.size()) - 1) * 5) >> 1,
                comparator);
    }

    private static void quickSort(CharList list, int from, int to, int remaining, CharComparator comparator) {
        if (to - from < INSERTION_THRESHOLD) {
            insertionSort(list, from, to, comparator);
            return;
        }
        if (remaining == 0) {
            heapSort(list, from, to, comparator);
            return;
        }
        remaining--;
        int pivotIndex = (from + to) >> 1;
        char pivot = list.get(pivotIndex);
        list.swap(pivotIndex, to);
        int storeIndex = from;
        int equalIndex = to;
        for (int i = from; i < equalIndex; i++) {
            int value = comparator.compare(list.get(i), pivot);
            if (value < 0) {
                list.swap(storeIndex++, i);
            } else if (value == 0) {
                list.swap(--equalIndex, i--);
            }
        }
        quickSort(list, from, storeIndex - 1, remaining, comparator);
        for (int i = equalIndex; i <= to; i++) {
            list.swap(storeIndex++, i);
        }
        quickSort(list, storeIndex, to, remaining, comparator);
    }

    private static void heapSort(CharList list, int from, int to, CharComparator comparator) {
        for (int i = (to + from - 1) >> 1; i >= from; i--) {
            siftDown(list, i, to, comparator, from);
        }
        for (int i = to; i > from; i--) {
            list.swap(from, i);
            siftDown(list, from, i - 1, comparator, from);
        }
    }

    private static void siftDown(CharList list, int start, int end, CharComparator comparator, int delta) {
        char value = list.get(start);
        while (true) {
            int child = ((start - delta) << 1) + 1 + delta;
            if (child > end) {
                return;
            }
            char childValue = list.get(child);
            if (child + 1 <= end) {
                char otherValue = list.get(child + 1);
                if (comparator.compare(otherValue, childValue) > 0) {
                    child++;
                    childValue = otherValue;
                }
            }
            if (comparator.compare(value, childValue) >= 0) {
                return;
            }
            list.swap(start, child);
            start = child;
        }
    }

    private static void insertionSort(CharList list, int from, int to, CharComparator comparator) {
        for (int i = from + 1; i <= to; i++) {
            char value = list.get(i);
            for (int j = i - 1; j >= from; j--) {
                if (comparator.compare(list.get(j), value) <= 0) {
                    break;
                }
                list.swap(j, j + 1);
            }
        }
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharComparator {
    public static final CharComparator DEFAULT = (first, second) -> {
        if (first < second) {
            return -1;
        }
        if (first > second) {
            return 1;
        }
        return 0;
    };

    public static final CharComparator REVERSE = (first, second) -> {
        if (first > second) {
            return -1;
        }
        if (first < second) {
            return 1;
        }
        return 0;
    };

    public int compare(char first, char second);
}
/**
 * @author Egor Kulikov
 */
 interface DoubleComparator {
    public static final DoubleComparator DEFAULT = (first, second) -> {
        if (first < second) {
            return -1;
        }
        if (first > second) {
            return 1;
        }
        return 0;
    };

    public static final DoubleComparator REVERSE = (first, second) -> {
        if (first > second) {
            return -1;
        }
        if (first < second) {
            return 1;
        }
        return 0;
    };

    public int compare(double first, double second);
}
/**
 * @author Egor Kulikov
 */
 interface IntComparator {
    public static final IntComparator DEFAULT = (first, second) -> {
        if (first < second) {
            return -1;
        }
        if (first > second) {
            return 1;
        }
        return 0;
    };

    public static final IntComparator REVERSE = (first, second) -> {
        if (first > second) {
            return -1;
        }
        if (first < second) {
            return 1;
        }
        return 0;
    };

    public int compare(int first, int second);
}
/**
 * @author Egor Kulikov
 */
 interface LongComparator {
    public static final LongComparator DEFAULT = (first, second) -> {
        if (first < second) {
            return -1;
        }
        if (first > second) {
            return 1;
        }
        return 0;
    };

    public static final LongComparator REVERSE = (first, second) -> {
        if (first > second) {
            return -1;
        }
        if (first < second) {
            return 1;
        }
        return 0;
    };

    public int compare(long first, long second);
}
/**
 * @author Egor Kulikov
 */
 class ReverseComparators {
    private ReverseComparators() {
    }

    public static DoubleComparator reverse(final DoubleComparator comparator) {
        return new DoubleComparator() {
            public int compare(double first, double second) {
                return comparator.compare(second, first);
            }
        };
    }

    public static IntComparator reverse(final IntComparator comparator) {
        return new IntComparator() {
            public int compare(int first, int second) {
                return comparator.compare(second, first);
            }
        };
    }

    public static LongComparator reverse(final LongComparator comparator) {
        return new LongComparator() {
            public int compare(long first, long second) {
                return comparator.compare(second, first);
            }
        };
    }

    public static CharComparator reverse(final CharComparator comparator) {
        return new CharComparator() {
            public int compare(char first, char second) {
                return comparator.compare(second, first);
            }
        };
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharIterator {
    public char value() throws NoSuchElementException;

    /**
     * Returns true if next call to isValid will return true
     */
    public boolean advance();

    public boolean isValid();

    public void remove();
}
/**
 * @author Egor Kulikov
 */
 interface DoubleIterator {
    public double value() throws NoSuchElementException;

    /**
     * Returns true if next call to isValid will return true
     */
    public boolean advance();

    public boolean isValid();

    public void remove();
}
/**
 * @author Egor Kulikov
 */
 interface IntIterator {
    public int value() throws NoSuchElementException;

    /**
     * Returns true if next call to isValid will return true
     */
    public boolean advance();

    public boolean isValid();

    public void remove();
}
/**
 * @author Egor Kulikov
 */
 interface LongIterator {
    public long value() throws NoSuchElementException;

    /**
     * Returns true if next call to isValid will return true
     */
    public boolean advance();

    public boolean isValid();

    public void remove();
}
/**
 * @author Egor Kulikov
 */
 interface CharCharPredicate {
    public boolean value(char first, char second);

    default public CharFilter setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharFilter setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharCharToCharFunction {
    public char value(char first, char second);

    default public CharToCharFunction setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharToCharFunction setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharCharToDoubleFunction {
    public double value(char first, char second);

    default public CharToDoubleFunction setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharToDoubleFunction setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharCharToIntFunction {
    public int value(char first, char second);

    default public CharToIntFunction setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharToIntFunction setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharCharToLongFunction {
    public long value(char first, char second);

    default public CharToLongFunction setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharToLongFunction setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharDoublePredicate {
    public boolean value(char first, double second);

    default public CharFilter setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleFilter setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharDoubleToCharFunction {
    public char value(char first, double second);

    default public CharToCharFunction setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleToCharFunction setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharDoubleToDoubleFunction {
    public double value(char first, double second);

    default public CharToDoubleFunction setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleToDoubleFunction setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharDoubleToIntFunction {
    public int value(char first, double second);

    default public CharToIntFunction setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleToIntFunction setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharDoubleToLongFunction {
    public long value(char first, double second);

    default public CharToLongFunction setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleToLongFunction setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharFilter {
    public boolean accept(char value);

    default public CharFilter or(CharFilter f) {
        return (val) -> CharFilter.this.accept(val) || f.accept(val);
    }

    default public CharFilter and(CharFilter f) {
        return (val) -> CharFilter.this.accept(val) && f.accept(val);
    }

    default public CharFilter xor(CharFilter f) {
        return (val) -> CharFilter.this.accept(val) ^ f.accept(val);
    }

    default public CharFilter not() {
        return (val) -> !CharFilter.this.accept(val);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharIntPredicate {
    public boolean value(char first, int second);

    default public CharFilter setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntFilter setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharIntToCharFunction {
    public char value(char first, int second);

    default public CharToCharFunction setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntToCharFunction setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharIntToDoubleFunction {
    public double value(char first, int second);

    default public CharToDoubleFunction setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntToDoubleFunction setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharIntToIntFunction {
    public int value(char first, int second);

    default public CharToIntFunction setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntToIntFunction setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharIntToLongFunction {
    public long value(char first, int second);

    default public CharToLongFunction setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntToLongFunction setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharLongPredicate {
    public boolean value(char first, long second);

    default public CharFilter setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongFilter setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharLongToCharFunction {
    public char value(char first, long second);

    default public CharToCharFunction setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongToCharFunction setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharLongToDoubleFunction {
    public double value(char first, long second);

    default public CharToDoubleFunction setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongToDoubleFunction setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharLongToIntFunction {
    public int value(char first, long second);

    default public CharToIntFunction setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongToIntFunction setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharLongToLongFunction {
    public long value(char first, long second);

    default public CharToLongFunction setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongToLongFunction setFirst(char first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharTask {
    public void process(char value);
}
/**
 * @author Egor Kulikov
 */
 interface CharToCharFunction {
    public char value(char key);

    default public DoubleToCharFunction combine(DoubleToCharFunction f) {
        return val -> value(f.value(val));
    }

    default public IntToCharFunction combine(IntToCharFunction f) {
        return val -> value(f.value(val));
    }

    default public LongToCharFunction combine(LongToCharFunction f) {
        return val -> value(f.value(val));
    }

    default public CharToCharFunction combine(CharToCharFunction f) {
        return val -> value(f.value(val));
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharToDoubleFunction {
    public double value(char key);

    default public DoubleToDoubleFunction combine(DoubleToCharFunction f) {
        return val -> value(f.value(val));
    }

    default public IntToDoubleFunction combine(IntToCharFunction f) {
        return val -> value(f.value(val));
    }

    default public LongToDoubleFunction combine(LongToCharFunction f) {
        return val -> value(f.value(val));
    }

    default public CharToDoubleFunction combine(CharToCharFunction f) {
        return val -> value(f.value(val));
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharToIntFunction {
    public int value(char key);

    default public DoubleToIntFunction combine(DoubleToCharFunction f) {
        return val -> value(f.value(val));
    }

    default public IntToIntFunction combine(IntToCharFunction f) {
        return val -> value(f.value(val));
    }

    default public LongToIntFunction combine(LongToCharFunction f) {
        return val -> value(f.value(val));
    }

    default public CharToIntFunction combine(CharToCharFunction f) {
        return val -> value(f.value(val));
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharToLongFunction {
    public long value(char key);

    default public DoubleToLongFunction combine(DoubleToCharFunction f) {
        return val -> value(f.value(val));
    }

    default public IntToLongFunction combine(IntToCharFunction f) {
        return val -> value(f.value(val));
    }

    default public LongToLongFunction combine(LongToCharFunction f) {
        return val -> value(f.value(val));
    }

    default public CharToLongFunction combine(CharToCharFunction f) {
        return val -> value(f.value(val));
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleCharPredicate {
    public boolean value(double first, char second);

    default public DoubleFilter setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharFilter setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleCharToCharFunction {
    public char value(double first, char second);

    default public DoubleToCharFunction setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharToCharFunction setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleCharToDoubleFunction {
    public double value(double first, char second);

    default public DoubleToDoubleFunction setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharToDoubleFunction setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleCharToIntFunction {
    public int value(double first, char second);

    default public DoubleToIntFunction setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharToIntFunction setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleCharToLongFunction {
    public long value(double first, char second);

    default public DoubleToLongFunction setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharToLongFunction setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleDoublePredicate {
    public boolean value(double first, double second);

    default public DoubleFilter setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleFilter setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleDoubleToCharFunction {
    public char value(double first, double second);

    default public DoubleToCharFunction setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleToCharFunction setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleDoubleToDoubleFunction {
    public double value(double first, double second);

    default public DoubleToDoubleFunction setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleToDoubleFunction setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleDoubleToIntFunction {
    public int value(double first, double second);

    default public DoubleToIntFunction setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleToIntFunction setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleDoubleToLongFunction {
    public long value(double first, double second);

    default public DoubleToLongFunction setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleToLongFunction setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleFilter {
    public boolean accept(double value);

    default public DoubleFilter or(DoubleFilter f) {
        return (val) -> DoubleFilter.this.accept(val) || f.accept(val);
    }

    default public DoubleFilter and(DoubleFilter f) {
        return (val) -> DoubleFilter.this.accept(val) && f.accept(val);
    }

    default public DoubleFilter xor(DoubleFilter f) {
        return (val) -> DoubleFilter.this.accept(val) ^ f.accept(val);
    }

    default public DoubleFilter not() {
        return (val) -> !DoubleFilter.this.accept(val);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleIntPredicate {
    public boolean value(double first, int second);

    default public DoubleFilter setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntFilter setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleIntToCharFunction {
    public char value(double first, int second);

    default public DoubleToCharFunction setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntToCharFunction setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleIntToDoubleFunction {
    public double value(double first, int second);

    default public DoubleToDoubleFunction setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntToDoubleFunction setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleIntToIntFunction {
    public int value(double first, int second);

    default public DoubleToIntFunction setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntToIntFunction setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleIntToLongFunction {
    public long value(double first, int second);

    default public DoubleToLongFunction setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntToLongFunction setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleLongPredicate {
    public boolean value(double first, long second);

    default public DoubleFilter setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongFilter setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleLongToCharFunction {
    public char value(double first, long second);

    default public DoubleToCharFunction setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongToCharFunction setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleLongToDoubleFunction {
    public double value(double first, long second);

    default public DoubleToDoubleFunction setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongToDoubleFunction setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleLongToIntFunction {
    public int value(double first, long second);

    default public DoubleToIntFunction setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongToIntFunction setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleLongToLongFunction {
    public long value(double first, long second);

    default public DoubleToLongFunction setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongToLongFunction setFirst(double first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleTask {
    public void process(double value);
}
/**
 * @author Egor Kulikov
 */
 interface DoubleToCharFunction {
    public char value(double key);

    default public DoubleToCharFunction combine(DoubleToDoubleFunction f) {
        return val -> value(f.value(val));
    }

    default public IntToCharFunction combine(IntToDoubleFunction f) {
        return val -> value(f.value(val));
    }

    default public LongToCharFunction combine(LongToDoubleFunction f) {
        return val -> value(f.value(val));
    }

    default public CharToCharFunction combine(CharToDoubleFunction f) {
        return val -> value(f.value(val));
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleToDoubleFunction {
    public double value(double key);

    default public DoubleToDoubleFunction combine(DoubleToDoubleFunction f) {
        return val -> value(f.value(val));
    }

    default public IntToDoubleFunction combine(IntToDoubleFunction f) {
        return val -> value(f.value(val));
    }

    default public LongToDoubleFunction combine(LongToDoubleFunction f) {
        return val -> value(f.value(val));
    }

    default public CharToDoubleFunction combine(CharToDoubleFunction f) {
        return val -> value(f.value(val));
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleToIntFunction {
    public int value(double key);

    default public DoubleToIntFunction combine(DoubleToDoubleFunction f) {
        return val -> value(f.value(val));
    }

    default public IntToIntFunction combine(IntToDoubleFunction f) {
        return val -> value(f.value(val));
    }

    default public LongToIntFunction combine(LongToDoubleFunction f) {
        return val -> value(f.value(val));
    }

    default public CharToIntFunction combine(CharToDoubleFunction f) {
        return val -> value(f.value(val));
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleToLongFunction {
    public long value(double key);

    default public DoubleToLongFunction combine(DoubleToDoubleFunction f) {
        return val -> value(f.value(val));
    }

    default public IntToLongFunction combine(IntToDoubleFunction f) {
        return val -> value(f.value(val));
    }

    default public LongToLongFunction combine(LongToDoubleFunction f) {
        return val -> value(f.value(val));
    }

    default public CharToLongFunction combine(CharToDoubleFunction f) {
        return val -> value(f.value(val));
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntCharPredicate {
    public boolean value(int first, char second);

    default public IntFilter setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharFilter setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntCharToCharFunction {
    public char value(int first, char second);

    default public IntToCharFunction setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharToCharFunction setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntCharToDoubleFunction {
    public double value(int first, char second);

    default public IntToDoubleFunction setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharToDoubleFunction setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntCharToIntFunction {
    public int value(int first, char second);

    default public IntToIntFunction setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharToIntFunction setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntCharToLongFunction {
    public long value(int first, char second);

    default public IntToLongFunction setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharToLongFunction setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntDoublePredicate {
    public boolean value(int first, double second);

    default public IntFilter setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleFilter setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntDoubleToCharFunction {
    public char value(int first, double second);

    default public IntToCharFunction setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleToCharFunction setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntDoubleToDoubleFunction {
    public double value(int first, double second);

    default public IntToDoubleFunction setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleToDoubleFunction setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntDoubleToIntFunction {
    public int value(int first, double second);

    default public IntToIntFunction setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleToIntFunction setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntDoubleToLongFunction {
    public long value(int first, double second);

    default public IntToLongFunction setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleToLongFunction setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntFilter {
    public boolean accept(int value);

    default public IntFilter or(IntFilter f) {
        return (val) -> IntFilter.this.accept(val) || f.accept(val);
    }

    default public IntFilter and(IntFilter f) {
        return (val) -> IntFilter.this.accept(val) && f.accept(val);
    }

    default public IntFilter xor(IntFilter f) {
        return (val) -> IntFilter.this.accept(val) ^ f.accept(val);
    }

    default public IntFilter not() {
        return (val) -> !IntFilter.this.accept(val);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntIntPredicate {
    public boolean value(int first, int second);

    default public IntFilter setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntFilter setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntIntToCharFunction {
    public char value(int first, int second);

    default public IntToCharFunction setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntToCharFunction setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntIntToDoubleFunction {
    public double value(int first, int second);

    default public IntToDoubleFunction setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntToDoubleFunction setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntIntToIntFunction {
    public int value(int first, int second);

    default public IntToIntFunction setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntToIntFunction setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntIntToLongFunction {
    public long value(int first, int second);

    default public IntToLongFunction setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntToLongFunction setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntLongPredicate {
    public boolean value(int first, long second);

    default public IntFilter setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongFilter setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntLongToCharFunction {
    public char value(int first, long second);

    default public IntToCharFunction setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongToCharFunction setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntLongToDoubleFunction {
    public double value(int first, long second);

    default public IntToDoubleFunction setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongToDoubleFunction setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntLongToIntFunction {
    public int value(int first, long second);

    default public IntToIntFunction setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongToIntFunction setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntLongToLongFunction {
    public long value(int first, long second);

    default public IntToLongFunction setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongToLongFunction setFirst(int first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntTask {
    public void process(int value);
}
/**
 * @author Egor Kulikov
 */
 interface IntToCharFunction {
    public char value(int key);

    default public DoubleToCharFunction combine(DoubleToIntFunction f) {
        return val -> value(f.value(val));
    }

    default public IntToCharFunction combine(IntToIntFunction f) {
        return val -> value(f.value(val));
    }

    default public LongToCharFunction combine(LongToIntFunction f) {
        return val -> value(f.value(val));
    }

    default public CharToCharFunction combine(CharToIntFunction f) {
        return val -> value(f.value(val));
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntToDoubleFunction {
    public double value(int key);

    default public DoubleToDoubleFunction combine(DoubleToIntFunction f) {
        return val -> value(f.value(val));
    }

    default public IntToDoubleFunction combine(IntToIntFunction f) {
        return val -> value(f.value(val));
    }

    default public LongToDoubleFunction combine(LongToIntFunction f) {
        return val -> value(f.value(val));
    }

    default public CharToDoubleFunction combine(CharToIntFunction f) {
        return val -> value(f.value(val));
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntToIntFunction {
    public int value(int key);

    default public DoubleToIntFunction combine(DoubleToIntFunction f) {
        return val -> value(f.value(val));
    }

    default public IntToIntFunction combine(IntToIntFunction f) {
        return val -> value(f.value(val));
    }

    default public LongToIntFunction combine(LongToIntFunction f) {
        return val -> value(f.value(val));
    }

    default public CharToIntFunction combine(CharToIntFunction f) {
        return val -> value(f.value(val));
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntToLongFunction {
    public long value(int key);

    default public DoubleToLongFunction combine(DoubleToIntFunction f) {
        return val -> value(f.value(val));
    }

    default public IntToLongFunction combine(IntToIntFunction f) {
        return val -> value(f.value(val));
    }

    default public LongToLongFunction combine(LongToIntFunction f) {
        return val -> value(f.value(val));
    }

    default public CharToLongFunction combine(CharToIntFunction f) {
        return val -> value(f.value(val));
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongCharPredicate {
    public boolean value(long first, char second);

    default public LongFilter setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharFilter setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongCharToCharFunction {
    public char value(long first, char second);

    default public LongToCharFunction setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharToCharFunction setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongCharToDoubleFunction {
    public double value(long first, char second);

    default public LongToDoubleFunction setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharToDoubleFunction setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongCharToIntFunction {
    public int value(long first, char second);

    default public LongToIntFunction setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharToIntFunction setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongCharToLongFunction {
    public long value(long first, char second);

    default public LongToLongFunction setSecond(char second) {
        return v -> value(v, second);
    }

    default public CharToLongFunction setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongDoublePredicate {
    public boolean value(long first, double second);

    default public LongFilter setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleFilter setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongDoubleToCharFunction {
    public char value(long first, double second);

    default public LongToCharFunction setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleToCharFunction setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongDoubleToDoubleFunction {
    public double value(long first, double second);

    default public LongToDoubleFunction setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleToDoubleFunction setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongDoubleToIntFunction {
    public int value(long first, double second);

    default public LongToIntFunction setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleToIntFunction setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongDoubleToLongFunction {
    public long value(long first, double second);

    default public LongToLongFunction setSecond(double second) {
        return v -> value(v, second);
    }

    default public DoubleToLongFunction setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongFilter {
    public boolean accept(long value);

    default public LongFilter or(LongFilter f) {
        return (val) -> LongFilter.this.accept(val) || f.accept(val);
    }

    default public LongFilter and(LongFilter f) {
        return (val) -> LongFilter.this.accept(val) && f.accept(val);
    }

    default public LongFilter xor(LongFilter f) {
        return (val) -> LongFilter.this.accept(val) ^ f.accept(val);
    }

    default public LongFilter not() {
        return (val) -> !LongFilter.this.accept(val);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongIntPredicate {
    public boolean value(long first, int second);

    default public LongFilter setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntFilter setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongIntToCharFunction {
    public char value(long first, int second);

    default public LongToCharFunction setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntToCharFunction setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongIntToDoubleFunction {
    public double value(long first, int second);

    default public LongToDoubleFunction setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntToDoubleFunction setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongIntToIntFunction {
    public int value(long first, int second);

    default public LongToIntFunction setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntToIntFunction setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongIntToLongFunction {
    public long value(long first, int second);

    default public LongToLongFunction setSecond(int second) {
        return v -> value(v, second);
    }

    default public IntToLongFunction setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongLongPredicate {
    public boolean value(long first, long second);

    default public LongFilter setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongFilter setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongLongToCharFunction {
    public char value(long first, long second);

    default public LongToCharFunction setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongToCharFunction setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongLongToDoubleFunction {
    public double value(long first, long second);

    default public LongToDoubleFunction setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongToDoubleFunction setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongLongToIntFunction {
    public int value(long first, long second);

    default public LongToIntFunction setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongToIntFunction setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongLongToLongFunction {
    public long value(long first, long second);

    default public LongToLongFunction setSecond(long second) {
        return v -> value(v, second);
    }

    default public LongToLongFunction setFirst(long first) {
        return v -> value(first, v);
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongTask {
    public void process(long value);
}
/**
 * @author Egor Kulikov
 */
 interface LongToCharFunction {
    public char value(long key);

    default public DoubleToCharFunction combine(DoubleToLongFunction f) {
        return val -> value(f.value(val));
    }

    default public IntToCharFunction combine(IntToLongFunction f) {
        return val -> value(f.value(val));
    }

    default public LongToCharFunction combine(LongToLongFunction f) {
        return val -> value(f.value(val));
    }

    default public CharToCharFunction combine(CharToLongFunction f) {
        return val -> value(f.value(val));
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongToDoubleFunction {
    public double value(long key);

    default public DoubleToDoubleFunction combine(DoubleToLongFunction f) {
        return val -> value(f.value(val));
    }

    default public IntToDoubleFunction combine(IntToLongFunction f) {
        return val -> value(f.value(val));
    }

    default public LongToDoubleFunction combine(LongToLongFunction f) {
        return val -> value(f.value(val));
    }

    default public CharToDoubleFunction combine(CharToLongFunction f) {
        return val -> value(f.value(val));
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongToIntFunction {
    public int value(long key);

    default public DoubleToIntFunction combine(DoubleToLongFunction f) {
        return val -> value(f.value(val));
    }

    default public IntToIntFunction combine(IntToLongFunction f) {
        return val -> value(f.value(val));
    }

    default public LongToIntFunction combine(LongToLongFunction f) {
        return val -> value(f.value(val));
    }

    default public CharToIntFunction combine(CharToLongFunction f) {
        return val -> value(f.value(val));
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongToLongFunction {
    public long value(long key);

    default public DoubleToLongFunction combine(DoubleToLongFunction f) {
        return val -> value(f.value(val));
    }

    default public IntToLongFunction combine(IntToLongFunction f) {
        return val -> value(f.value(val));
    }

    default public LongToLongFunction combine(LongToLongFunction f) {
        return val -> value(f.value(val));
    }

    default public CharToLongFunction combine(CharToLongFunction f) {
        return val -> value(f.value(val));
    }
}
abstract class CharAbstractStream implements CharStream {
    //base
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        boolean first = true;
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            if (first) {
                first = false;
            } else {
                builder.append(' ');
            }
            builder.append(it.value());
        }
        return builder.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof CharStream)) {
            return false;
        }
        CharStream c = (CharStream) o;
        CharIterator it = charIterator();
        CharIterator jt = c.charIterator();
        while (it.isValid() && jt.isValid()) {
            if (it.value() != jt.value()) {
                return false;
            }
            it.advance();
            jt.advance();
        }
        return !it.isValid() && !jt.isValid();
    }

    @Override
    public int hashCode() {
        int result = 0;
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            result *= 31;
            result += it.value();
        }
        return result;
    }
}
/**
 * @author Egor Kulikov
 */
 interface CharCollection extends CharStream {
    //abstract
    public int size();

    //base
    default public boolean isEmpty() {
        return size() == 0;
    }

    default public void add(char value) {
        throw new UnsupportedOperationException();
    }

    default public boolean remove(char value) {
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            if (value == it.value()) {
                it.remove();
                return true;
            }
        }
        return false;
    }

    default public char[] toArray() {
        int size = size();
        char[] array = new char[size];
        int i = 0;
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            array[i++] = it.value();
        }
        return array;
    }

    default public CharCollection addAll(CharStream values) {
        for (CharIterator it = values.charIterator(); it.isValid(); it.advance()) {
            add(it.value());
        }
        return this;
    }

    default public CharCollection removeAll(CharStream values) {
        for (CharIterator it = values.charIterator(); it.isValid(); it.advance()) {
            remove(it.value());
        }
        return this;
    }

    default public CharCollection retainAll(CharCollection values) {
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            if (!values.contains(it.value())) {
                it.remove();
            }
        }
        return this;
    }

    default public CharCollection compute() {
        return this;
    }
}
interface CharReversableCollection extends CharCollection {
    //abstract
    public CharIterator reverseIterator();

    //base
    default public char last() {
        return reverseIterator().value();
    }

    default CharStream reversed() {
        return () -> reverseIterator();
    }
}
interface CharStream extends Iterable<Character>, Comparable<CharStream> {
    //abstract
    public CharIterator charIterator();

    //base
    default public Iterator<Character> iterator() {
        return new Iterator<Character>() {
            private CharIterator it = charIterator();

            public boolean hasNext() {
                return it.isValid();
            }

            public Character next() {
                char result = it.value();
                it.advance();
                return result;
            }
        };
    }

    default public char first() {
        return charIterator().value();
    }

    default public CharCollection compute() {
        return new CharArrayList(this);
    }

    default public int compareTo(CharStream c) {
        CharIterator it = charIterator();
        CharIterator jt = c.charIterator();
        while (it.isValid() && jt.isValid()) {
            char i = it.value();
            char j = jt.value();
            if (i < j) {
                return -1;
            } else if (i > j) {
                return 1;
            }
            it.advance();
            jt.advance();
        }
        if (it.isValid()) {
            return 1;
        }
        if (jt.isValid()) {
            return -1;
        }
        return 0;
    }

    //algorithms
    default public void forEach(CharTask task) {
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            task.process(it.value());
        }
    }

    default public boolean contains(char value) {
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            if (it.value() == value) {
                return true;
            }
        }
        return false;
    }

    default public boolean contains(CharFilter filter) {
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            if (filter.accept(it.value())) {
                return true;
            }
        }
        return false;
    }

    default public int count(char value) {
        int result = 0;
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            if (it.value() == value) {
                result++;
            }
        }
        return result;
    }

    default public int count(CharFilter filter) {
        int result = 0;
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            if (filter.accept(it.value())) {
                result++;
            }
        }
        return result;
    }

    default public char min() {
        char result = Character.MAX_VALUE;
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            char current = it.value();
            if (current < result) {
                result = current;
            }
        }
        return result;
    }

    default public char min(CharComparator comparator) {
        char result = Character.MAX_VALUE;
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            char current = it.value();
            if (result == Character.MAX_VALUE || comparator.compare(result, current) > 0) {
                result = current;
            }
        }
        return result;
    }

    default public char max() {
        char result = Character.MIN_VALUE;
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            char current = it.value();
            if (current > result) {
                result = current;
            }
        }
        return result;
    }

    default public char max(CharComparator comparator) {
        char result = Character.MAX_VALUE;
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            char current = it.value();
            if (result == Character.MAX_VALUE || comparator.compare(result, current) < 0) {
                result = current;
            }
        }
        return result;
    }

    default public int sum() {
        int result = 0;
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            result += it.value();
        }
        return result;
    }

    default public int[] qty(int bound) {
        int[] result = new int[bound];
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            result[(int) it.value()]++;
        }
        return result;
    }

    default public int[] qty() {
        return qty((int) (max() + 1));
    }

    default public boolean allOf(CharFilter f) {
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            if (!f.accept(it.value())) {
                return false;
            }
        }
        return true;
    }

    default public boolean anyOf(CharFilter f) {
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            if (f.accept(it.value())) {
                return true;
            }
        }
        return false;
    }

    default public boolean noneOf(CharFilter f) {
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            if (f.accept(it.value())) {
                return false;
            }
        }
        return true;
    }

    default public char reduce(CharCharToCharFunction f) {
        CharIterator it = charIterator();
        if (!it.isValid()) {
            return Character.MAX_VALUE;
        }
        char result = it.value();
        while (it.advance()) {
            result = f.value(result, it.value());
        }
        return result;
    }

    default public double reduce(double initial, DoubleCharToDoubleFunction f) {
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            initial = f.value(initial, it.value());
        }
        return initial;
    }

    default public int reduce(int initial, IntCharToIntFunction f) {
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            initial = f.value(initial, it.value());
        }
        return initial;
    }

    default public long reduce(long initial, LongCharToLongFunction f) {
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            initial = f.value(initial, it.value());
        }
        return initial;
    }

    default public char reduce(char initial, CharCharToCharFunction f) {
        for (CharIterator it = charIterator(); it.isValid(); it.advance()) {
            initial = f.value(initial, it.value());
        }
        return initial;
    }

    //views
    default public CharStream union(CharStream other) {
        return () -> new CharIterator() {
            private CharIterator first = CharStream.this.charIterator();
            private CharIterator second;

            public char value() throws NoSuchElementException {
                if (first.isValid()) {
                    return first.value();
                }
                return second.value();
            }

            public boolean advance() throws NoSuchElementException {
                if (first.isValid()) {
                    first.advance();
                    if (!first.isValid()) {
                        second = other.charIterator();
                    }
                    return second.isValid();
                } else {
                    return second.advance();
                }
            }

            public boolean isValid() {
                return first.isValid() || second.isValid();
            }

            public void remove() {
                if (first.isValid()) {
                    first.remove();
                } else {
                    second.remove();
                }
            }
        };
    }

    default public CharStream filter(CharFilter f) {
        return () -> new CharIterator() {
            private CharIterator it = CharStream.this.charIterator();

            {
                next();
            }

            private void next() {
                while (it.isValid() && !f.accept(it.value())) {
                    it.advance();
                }
            }

            public char value() {
                return it.value();
            }

            public boolean advance() {
                it.advance();
                next();
                return isValid();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public DoubleStream map(CharToDoubleFunction function) {
        return () -> new DoubleIterator() {
            private CharIterator it = CharStream.this.charIterator();

            public double value() {
                return function.value(it.value());
            }

            public boolean advance() {
                return it.advance();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public IntStream map(CharToIntFunction function) {
        return () -> new IntIterator() {
            private CharIterator it = CharStream.this.charIterator();

            public int value() {
                return function.value(it.value());
            }

            public boolean advance() {
                return it.advance();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public LongStream map(CharToLongFunction function) {
        return () -> new LongIterator() {
            private CharIterator it = CharStream.this.charIterator();

            public long value() {
                return function.value(it.value());
            }

            public boolean advance() {
                return it.advance();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public CharStream map(CharToCharFunction function) {
        return () -> new CharIterator() {
            private CharIterator it = CharStream.this.charIterator();

            public char value() {
                return function.value(it.value());
            }

            public boolean advance() {
                return it.advance();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public DoubleStream join(DoubleStream other, CharDoubleToDoubleFunction f) {
        return () -> new DoubleIterator() {
            private CharIterator it = CharStream.this.charIterator();
            private DoubleIterator jt = other.doubleIterator();

            public double value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public IntStream join(DoubleStream other, CharDoubleToIntFunction f) {
        return () -> new IntIterator() {
            private CharIterator it = CharStream.this.charIterator();
            private DoubleIterator jt = other.doubleIterator();

            public int value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public LongStream join(DoubleStream other, CharDoubleToLongFunction f) {
        return () -> new LongIterator() {
            private CharIterator it = CharStream.this.charIterator();
            private DoubleIterator jt = other.doubleIterator();

            public long value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public CharStream join(DoubleStream other, CharDoubleToCharFunction f) {
        return () -> new CharIterator() {
            private CharIterator it = CharStream.this.charIterator();
            private DoubleIterator jt = other.doubleIterator();

            public char value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public DoubleStream join(IntStream other, CharIntToDoubleFunction f) {
        return () -> new DoubleIterator() {
            private CharIterator it = CharStream.this.charIterator();
            private IntIterator jt = other.intIterator();

            public double value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public IntStream join(IntStream other, CharIntToIntFunction f) {
        return () -> new IntIterator() {
            private CharIterator it = CharStream.this.charIterator();
            private IntIterator jt = other.intIterator();

            public int value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public LongStream join(IntStream other, CharIntToLongFunction f) {
        return () -> new LongIterator() {
            private CharIterator it = CharStream.this.charIterator();
            private IntIterator jt = other.intIterator();

            public long value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public CharStream join(IntStream other, CharIntToCharFunction f) {
        return () -> new CharIterator() {
            private CharIterator it = CharStream.this.charIterator();
            private IntIterator jt = other.intIterator();

            public char value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public DoubleStream join(LongStream other, CharLongToDoubleFunction f) {
        return () -> new DoubleIterator() {
            private CharIterator it = CharStream.this.charIterator();
            private LongIterator jt = other.longIterator();

            public double value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public IntStream join(LongStream other, CharLongToIntFunction f) {
        return () -> new IntIterator() {
            private CharIterator it = CharStream.this.charIterator();
            private LongIterator jt = other.longIterator();

            public int value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public LongStream join(LongStream other, CharLongToLongFunction f) {
        return () -> new LongIterator() {
            private CharIterator it = CharStream.this.charIterator();
            private LongIterator jt = other.longIterator();

            public long value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public CharStream join(LongStream other, CharLongToCharFunction f) {
        return () -> new CharIterator() {
            private CharIterator it = CharStream.this.charIterator();
            private LongIterator jt = other.longIterator();

            public char value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public DoubleStream join(CharStream other, CharCharToDoubleFunction f) {
        return () -> new DoubleIterator() {
            private CharIterator it = CharStream.this.charIterator();
            private CharIterator jt = other.charIterator();

            public double value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public IntStream join(CharStream other, CharCharToIntFunction f) {
        return () -> new IntIterator() {
            private CharIterator it = CharStream.this.charIterator();
            private CharIterator jt = other.charIterator();

            public int value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public LongStream join(CharStream other, CharCharToLongFunction f) {
        return () -> new LongIterator() {
            private CharIterator it = CharStream.this.charIterator();
            private CharIterator jt = other.charIterator();

            public long value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public CharStream join(CharStream other, CharCharToCharFunction f) {
        return () -> new CharIterator() {
            private CharIterator it = CharStream.this.charIterator();
            private CharIterator jt = other.charIterator();

            public char value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }
}
abstract class DoubleAbstractStream implements DoubleStream {
    //base
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        boolean first = true;
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            if (first) {
                first = false;
            } else {
                builder.append(' ');
            }
            builder.append(it.value());
        }
        return builder.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof DoubleStream)) {
            return false;
        }
        DoubleStream c = (DoubleStream) o;
        DoubleIterator it = doubleIterator();
        DoubleIterator jt = c.doubleIterator();
        while (it.isValid() && jt.isValid()) {
            if (it.value() != jt.value()) {
                return false;
            }
            it.advance();
            jt.advance();
        }
        return !it.isValid() && !jt.isValid();
    }

    @Override
    public int hashCode() {
        int result = 0;
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            result *= 31;
            result += it.value();
        }
        return result;
    }
}
/**
 * @author Egor Kulikov
 */
 interface DoubleCollection extends DoubleStream {
    //abstract
    public int size();

    //base
    default public boolean isEmpty() {
        return size() == 0;
    }

    default public void add(double value) {
        throw new UnsupportedOperationException();
    }

    default public boolean remove(double value) {
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            if (value == it.value()) {
                it.remove();
                return true;
            }
        }
        return false;
    }

    default public double[] toArray() {
        int size = size();
        double[] array = new double[size];
        int i = 0;
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            array[i++] = it.value();
        }
        return array;
    }

    default public DoubleCollection addAll(DoubleStream values) {
        for (DoubleIterator it = values.doubleIterator(); it.isValid(); it.advance()) {
            add(it.value());
        }
        return this;
    }

    default public DoubleCollection removeAll(DoubleStream values) {
        for (DoubleIterator it = values.doubleIterator(); it.isValid(); it.advance()) {
            remove(it.value());
        }
        return this;
    }

    default public DoubleCollection retainAll(DoubleCollection values) {
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            if (!values.contains(it.value())) {
                it.remove();
            }
        }
        return this;
    }

    default public DoubleCollection compute() {
        return this;
    }
}
interface DoubleReversableCollection extends DoubleCollection {
    //abstract
    public DoubleIterator reverseIterator();

    //base
    default public double last() {
        return reverseIterator().value();
    }

    default DoubleStream reversed() {
        return () -> reverseIterator();
    }
}
interface DoubleStream extends Iterable<Double>, Comparable<DoubleStream> {
    //abstract
    public DoubleIterator doubleIterator();

    //base
    default public Iterator<Double> iterator() {
        return new Iterator<Double>() {
            private DoubleIterator it = doubleIterator();

            public boolean hasNext() {
                return it.isValid();
            }

            public Double next() {
                double result = it.value();
                it.advance();
                return result;
            }
        };
    }

    default public double first() {
        return doubleIterator().value();
    }

    default public DoubleCollection compute() {
        return new DoubleArrayList(this);
    }

    default public int compareTo(DoubleStream c) {
        DoubleIterator it = doubleIterator();
        DoubleIterator jt = c.doubleIterator();
        while (it.isValid() && jt.isValid()) {
            double i = it.value();
            double j = jt.value();
            if (i < j) {
                return -1;
            } else if (i > j) {
                return 1;
            }
            it.advance();
            jt.advance();
        }
        if (it.isValid()) {
            return 1;
        }
        if (jt.isValid()) {
            return -1;
        }
        return 0;
    }

    //algorithms
    default public void forEach(DoubleTask task) {
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            task.process(it.value());
        }
    }

    default public boolean contains(double value) {
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            if (it.value() == value) {
                return true;
            }
        }
        return false;
    }

    default public boolean contains(DoubleFilter filter) {
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            if (filter.accept(it.value())) {
                return true;
            }
        }
        return false;
    }

    default public int count(double value) {
        int result = 0;
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            if (it.value() == value) {
                result++;
            }
        }
        return result;
    }

    default public int count(DoubleFilter filter) {
        int result = 0;
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            if (filter.accept(it.value())) {
                result++;
            }
        }
        return result;
    }

    default public double min() {
        double result = Double.POSITIVE_INFINITY;
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            double current = it.value();
            if (current < result) {
                result = current;
            }
        }
        return result;
    }

    default public double min(DoubleComparator comparator) {
        double result = Double.MIN_NORMAL;
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            double current = it.value();
            if (result == Double.MIN_NORMAL || comparator.compare(result, current) > 0) {
                result = current;
            }
        }
        return result;
    }

    default public double max() {
        double result = Double.NEGATIVE_INFINITY;
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            double current = it.value();
            if (current > result) {
                result = current;
            }
        }
        return result;
    }

    default public double max(DoubleComparator comparator) {
        double result = Double.MIN_NORMAL;
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            double current = it.value();
            if (result == Double.MIN_NORMAL || comparator.compare(result, current) < 0) {
                result = current;
            }
        }
        return result;
    }

    default public double sum() {
        double result = 0;
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            result += it.value();
        }
        return result;
    }

    default public int[] qty(int bound) {
        int[] result = new int[bound];
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            result[(int) it.value()]++;
        }
        return result;
    }

    default public int[] qty() {
        return qty((int) (max() + 1));
    }

    default public boolean allOf(DoubleFilter f) {
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            if (!f.accept(it.value())) {
                return false;
            }
        }
        return true;
    }

    default public boolean anyOf(DoubleFilter f) {
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            if (f.accept(it.value())) {
                return true;
            }
        }
        return false;
    }

    default public boolean noneOf(DoubleFilter f) {
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            if (f.accept(it.value())) {
                return false;
            }
        }
        return true;
    }

    default public double reduce(DoubleDoubleToDoubleFunction f) {
        DoubleIterator it = doubleIterator();
        if (!it.isValid()) {
            return Double.MIN_NORMAL;
        }
        double result = it.value();
        while (it.advance()) {
            result = f.value(result, it.value());
        }
        return result;
    }

    default public double reduce(double initial, DoubleDoubleToDoubleFunction f) {
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            initial = f.value(initial, it.value());
        }
        return initial;
    }

    default public int reduce(int initial, IntDoubleToIntFunction f) {
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            initial = f.value(initial, it.value());
        }
        return initial;
    }

    default public long reduce(long initial, LongDoubleToLongFunction f) {
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            initial = f.value(initial, it.value());
        }
        return initial;
    }

    default public char reduce(char initial, CharDoubleToCharFunction f) {
        for (DoubleIterator it = doubleIterator(); it.isValid(); it.advance()) {
            initial = f.value(initial, it.value());
        }
        return initial;
    }

    //views
    default public DoubleStream union(DoubleStream other) {
        return () -> new DoubleIterator() {
            private DoubleIterator first = DoubleStream.this.doubleIterator();
            private DoubleIterator second;

            public double value() throws NoSuchElementException {
                if (first.isValid()) {
                    return first.value();
                }
                return second.value();
            }

            public boolean advance() throws NoSuchElementException {
                if (first.isValid()) {
                    first.advance();
                    if (!first.isValid()) {
                        second = other.doubleIterator();
                    }
                    return second.isValid();
                } else {
                    return second.advance();
                }
            }

            public boolean isValid() {
                return first.isValid() || second.isValid();
            }

            public void remove() {
                if (first.isValid()) {
                    first.remove();
                } else {
                    second.remove();
                }
            }
        };
    }

    default public DoubleStream filter(DoubleFilter f) {
        return () -> new DoubleIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();

            {
                next();
            }

            private void next() {
                while (it.isValid() && !f.accept(it.value())) {
                    it.advance();
                }
            }

            public double value() {
                return it.value();
            }

            public boolean advance() {
                it.advance();
                next();
                return isValid();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public DoubleStream map(DoubleToDoubleFunction function) {
        return () -> new DoubleIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();

            public double value() {
                return function.value(it.value());
            }

            public boolean advance() {
                return it.advance();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public IntStream map(DoubleToIntFunction function) {
        return () -> new IntIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();

            public int value() {
                return function.value(it.value());
            }

            public boolean advance() {
                return it.advance();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public LongStream map(DoubleToLongFunction function) {
        return () -> new LongIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();

            public long value() {
                return function.value(it.value());
            }

            public boolean advance() {
                return it.advance();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public CharStream map(DoubleToCharFunction function) {
        return () -> new CharIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();

            public char value() {
                return function.value(it.value());
            }

            public boolean advance() {
                return it.advance();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public DoubleStream join(DoubleStream other, DoubleDoubleToDoubleFunction f) {
        return () -> new DoubleIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();
            private DoubleIterator jt = other.doubleIterator();

            public double value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public IntStream join(DoubleStream other, DoubleDoubleToIntFunction f) {
        return () -> new IntIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();
            private DoubleIterator jt = other.doubleIterator();

            public int value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public LongStream join(DoubleStream other, DoubleDoubleToLongFunction f) {
        return () -> new LongIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();
            private DoubleIterator jt = other.doubleIterator();

            public long value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public CharStream join(DoubleStream other, DoubleDoubleToCharFunction f) {
        return () -> new CharIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();
            private DoubleIterator jt = other.doubleIterator();

            public char value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public DoubleStream join(IntStream other, DoubleIntToDoubleFunction f) {
        return () -> new DoubleIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();
            private IntIterator jt = other.intIterator();

            public double value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public IntStream join(IntStream other, DoubleIntToIntFunction f) {
        return () -> new IntIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();
            private IntIterator jt = other.intIterator();

            public int value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public LongStream join(IntStream other, DoubleIntToLongFunction f) {
        return () -> new LongIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();
            private IntIterator jt = other.intIterator();

            public long value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public CharStream join(IntStream other, DoubleIntToCharFunction f) {
        return () -> new CharIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();
            private IntIterator jt = other.intIterator();

            public char value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public DoubleStream join(LongStream other, DoubleLongToDoubleFunction f) {
        return () -> new DoubleIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();
            private LongIterator jt = other.longIterator();

            public double value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public IntStream join(LongStream other, DoubleLongToIntFunction f) {
        return () -> new IntIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();
            private LongIterator jt = other.longIterator();

            public int value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public LongStream join(LongStream other, DoubleLongToLongFunction f) {
        return () -> new LongIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();
            private LongIterator jt = other.longIterator();

            public long value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public CharStream join(LongStream other, DoubleLongToCharFunction f) {
        return () -> new CharIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();
            private LongIterator jt = other.longIterator();

            public char value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public DoubleStream join(CharStream other, DoubleCharToDoubleFunction f) {
        return () -> new DoubleIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();
            private CharIterator jt = other.charIterator();

            public double value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public IntStream join(CharStream other, DoubleCharToIntFunction f) {
        return () -> new IntIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();
            private CharIterator jt = other.charIterator();

            public int value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public LongStream join(CharStream other, DoubleCharToLongFunction f) {
        return () -> new LongIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();
            private CharIterator jt = other.charIterator();

            public long value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public CharStream join(CharStream other, DoubleCharToCharFunction f) {
        return () -> new CharIterator() {
            private DoubleIterator it = DoubleStream.this.doubleIterator();
            private CharIterator jt = other.charIterator();

            public char value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }
}
abstract class IntAbstractStream implements IntStream {
    //base
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        boolean first = true;
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            if (first) {
                first = false;
            } else {
                builder.append(' ');
            }
            builder.append(it.value());
        }
        return builder.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof IntStream)) {
            return false;
        }
        IntStream c = (IntStream) o;
        IntIterator it = intIterator();
        IntIterator jt = c.intIterator();
        while (it.isValid() && jt.isValid()) {
            if (it.value() != jt.value()) {
                return false;
            }
            it.advance();
            jt.advance();
        }
        return !it.isValid() && !jt.isValid();
    }

    @Override
    public int hashCode() {
        int result = 0;
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            result *= 31;
            result += it.value();
        }
        return result;
    }
}
/**
 * @author Egor Kulikov
 */
 interface IntCollection extends IntStream {
    //abstract
    public int size();

    //base
    default public boolean isEmpty() {
        return size() == 0;
    }

    default public void add(int value) {
        throw new UnsupportedOperationException();
    }

    default public boolean remove(int value) {
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            if (value == it.value()) {
                it.remove();
                return true;
            }
        }
        return false;
    }

    default public int[] toArray() {
        int size = size();
        int[] array = new int[size];
        int i = 0;
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            array[i++] = it.value();
        }
        return array;
    }

    default public IntCollection addAll(IntStream values) {
        for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {
            add(it.value());
        }
        return this;
    }

    default public IntCollection removeAll(IntStream values) {
        for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {
            remove(it.value());
        }
        return this;
    }

    default public IntCollection retainAll(IntCollection values) {
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            if (!values.contains(it.value())) {
                it.remove();
            }
        }
        return this;
    }

    default public IntCollection compute() {
        return this;
    }
}
interface IntReversableCollection extends IntCollection {
    //abstract
    public IntIterator reverseIterator();

    //base
    default public int last() {
        return reverseIterator().value();
    }

    default IntStream reversed() {
        return () -> reverseIterator();
    }
}
interface IntStream extends Iterable<Integer>, Comparable<IntStream> {
    //abstract
    public IntIterator intIterator();

    //base
    default public Iterator<Integer> iterator() {
        return new Iterator<Integer>() {
            private IntIterator it = intIterator();

            public boolean hasNext() {
                return it.isValid();
            }

            public Integer next() {
                int result = it.value();
                it.advance();
                return result;
            }
        };
    }

    default public int first() {
        return intIterator().value();
    }

    default public IntCollection compute() {
        return new IntArrayList(this);
    }

    default public int compareTo(IntStream c) {
        IntIterator it = intIterator();
        IntIterator jt = c.intIterator();
        while (it.isValid() && jt.isValid()) {
            int i = it.value();
            int j = jt.value();
            if (i < j) {
                return -1;
            } else if (i > j) {
                return 1;
            }
            it.advance();
            jt.advance();
        }
        if (it.isValid()) {
            return 1;
        }
        if (jt.isValid()) {
            return -1;
        }
        return 0;
    }

    //algorithms
    default public void forEach(IntTask task) {
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            task.process(it.value());
        }
    }

    default public boolean contains(int value) {
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            if (it.value() == value) {
                return true;
            }
        }
        return false;
    }

    default public boolean contains(IntFilter filter) {
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            if (filter.accept(it.value())) {
                return true;
            }
        }
        return false;
    }

    default public int count(int value) {
        int result = 0;
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            if (it.value() == value) {
                result++;
            }
        }
        return result;
    }

    default public int count(IntFilter filter) {
        int result = 0;
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            if (filter.accept(it.value())) {
                result++;
            }
        }
        return result;
    }

    default public int min() {
        int result = Integer.MAX_VALUE;
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            int current = it.value();
            if (current < result) {
                result = current;
            }
        }
        return result;
    }

    default public int min(IntComparator comparator) {
        int result = Integer.MIN_VALUE;
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            int current = it.value();
            if (result == Integer.MIN_VALUE || comparator.compare(result, current) > 0) {
                result = current;
            }
        }
        return result;
    }

    default public int max() {
        int result = Integer.MIN_VALUE;
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            int current = it.value();
            if (current > result) {
                result = current;
            }
        }
        return result;
    }

    default public int max(IntComparator comparator) {
        int result = Integer.MIN_VALUE;
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            int current = it.value();
            if (result == Integer.MIN_VALUE || comparator.compare(result, current) < 0) {
                result = current;
            }
        }
        return result;
    }

    default public long sum() {
        long result = 0;
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            result += it.value();
        }
        return result;
    }

    default public int[] qty(int bound) {
        int[] result = new int[bound];
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            result[(int) it.value()]++;
        }
        return result;
    }

    default public int[] qty() {
        return qty((int) (max() + 1));
    }

    default public boolean allOf(IntFilter f) {
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            if (!f.accept(it.value())) {
                return false;
            }
        }
        return true;
    }

    default public boolean anyOf(IntFilter f) {
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            if (f.accept(it.value())) {
                return true;
            }
        }
        return false;
    }

    default public boolean noneOf(IntFilter f) {
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            if (f.accept(it.value())) {
                return false;
            }
        }
        return true;
    }

    default public int reduce(IntIntToIntFunction f) {
        IntIterator it = intIterator();
        if (!it.isValid()) {
            return Integer.MIN_VALUE;
        }
        int result = it.value();
        while (it.advance()) {
            result = f.value(result, it.value());
        }
        return result;
    }

    default public double reduce(double initial, DoubleIntToDoubleFunction f) {
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            initial = f.value(initial, it.value());
        }
        return initial;
    }

    default public int reduce(int initial, IntIntToIntFunction f) {
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            initial = f.value(initial, it.value());
        }
        return initial;
    }

    default public long reduce(long initial, LongIntToLongFunction f) {
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            initial = f.value(initial, it.value());
        }
        return initial;
    }

    default public char reduce(char initial, CharIntToCharFunction f) {
        for (IntIterator it = intIterator(); it.isValid(); it.advance()) {
            initial = f.value(initial, it.value());
        }
        return initial;
    }

    //views
    default public IntStream union(IntStream other) {
        return () -> new IntIterator() {
            private IntIterator first = IntStream.this.intIterator();
            private IntIterator second;

            public int value() throws NoSuchElementException {
                if (first.isValid()) {
                    return first.value();
                }
                return second.value();
            }

            public boolean advance() throws NoSuchElementException {
                if (first.isValid()) {
                    first.advance();
                    if (!first.isValid()) {
                        second = other.intIterator();
                    }
                    return second.isValid();
                } else {
                    return second.advance();
                }
            }

            public boolean isValid() {
                return first.isValid() || second.isValid();
            }

            public void remove() {
                if (first.isValid()) {
                    first.remove();
                } else {
                    second.remove();
                }
            }
        };
    }

    default public IntStream filter(IntFilter f) {
        return () -> new IntIterator() {
            private IntIterator it = IntStream.this.intIterator();

            {
                next();
            }

            private void next() {
                while (it.isValid() && !f.accept(it.value())) {
                    it.advance();
                }
            }

            public int value() {
                return it.value();
            }

            public boolean advance() {
                it.advance();
                next();
                return isValid();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public DoubleStream map(IntToDoubleFunction function) {
        return () -> new DoubleIterator() {
            private IntIterator it = IntStream.this.intIterator();

            public double value() {
                return function.value(it.value());
            }

            public boolean advance() {
                return it.advance();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public IntStream map(IntToIntFunction function) {
        return () -> new IntIterator() {
            private IntIterator it = IntStream.this.intIterator();

            public int value() {
                return function.value(it.value());
            }

            public boolean advance() {
                return it.advance();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public LongStream map(IntToLongFunction function) {
        return () -> new LongIterator() {
            private IntIterator it = IntStream.this.intIterator();

            public long value() {
                return function.value(it.value());
            }

            public boolean advance() {
                return it.advance();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public CharStream map(IntToCharFunction function) {
        return () -> new CharIterator() {
            private IntIterator it = IntStream.this.intIterator();

            public char value() {
                return function.value(it.value());
            }

            public boolean advance() {
                return it.advance();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public DoubleStream join(DoubleStream other, IntDoubleToDoubleFunction f) {
        return () -> new DoubleIterator() {
            private IntIterator it = IntStream.this.intIterator();
            private DoubleIterator jt = other.doubleIterator();

            public double value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public IntStream join(DoubleStream other, IntDoubleToIntFunction f) {
        return () -> new IntIterator() {
            private IntIterator it = IntStream.this.intIterator();
            private DoubleIterator jt = other.doubleIterator();

            public int value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public LongStream join(DoubleStream other, IntDoubleToLongFunction f) {
        return () -> new LongIterator() {
            private IntIterator it = IntStream.this.intIterator();
            private DoubleIterator jt = other.doubleIterator();

            public long value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public CharStream join(DoubleStream other, IntDoubleToCharFunction f) {
        return () -> new CharIterator() {
            private IntIterator it = IntStream.this.intIterator();
            private DoubleIterator jt = other.doubleIterator();

            public char value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public DoubleStream join(IntStream other, IntIntToDoubleFunction f) {
        return () -> new DoubleIterator() {
            private IntIterator it = IntStream.this.intIterator();
            private IntIterator jt = other.intIterator();

            public double value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public IntStream join(IntStream other, IntIntToIntFunction f) {
        return () -> new IntIterator() {
            private IntIterator it = IntStream.this.intIterator();
            private IntIterator jt = other.intIterator();

            public int value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public LongStream join(IntStream other, IntIntToLongFunction f) {
        return () -> new LongIterator() {
            private IntIterator it = IntStream.this.intIterator();
            private IntIterator jt = other.intIterator();

            public long value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public CharStream join(IntStream other, IntIntToCharFunction f) {
        return () -> new CharIterator() {
            private IntIterator it = IntStream.this.intIterator();
            private IntIterator jt = other.intIterator();

            public char value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public DoubleStream join(LongStream other, IntLongToDoubleFunction f) {
        return () -> new DoubleIterator() {
            private IntIterator it = IntStream.this.intIterator();
            private LongIterator jt = other.longIterator();

            public double value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public IntStream join(LongStream other, IntLongToIntFunction f) {
        return () -> new IntIterator() {
            private IntIterator it = IntStream.this.intIterator();
            private LongIterator jt = other.longIterator();

            public int value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public LongStream join(LongStream other, IntLongToLongFunction f) {
        return () -> new LongIterator() {
            private IntIterator it = IntStream.this.intIterator();
            private LongIterator jt = other.longIterator();

            public long value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public CharStream join(LongStream other, IntLongToCharFunction f) {
        return () -> new CharIterator() {
            private IntIterator it = IntStream.this.intIterator();
            private LongIterator jt = other.longIterator();

            public char value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public DoubleStream join(CharStream other, IntCharToDoubleFunction f) {
        return () -> new DoubleIterator() {
            private IntIterator it = IntStream.this.intIterator();
            private CharIterator jt = other.charIterator();

            public double value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public IntStream join(CharStream other, IntCharToIntFunction f) {
        return () -> new IntIterator() {
            private IntIterator it = IntStream.this.intIterator();
            private CharIterator jt = other.charIterator();

            public int value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public LongStream join(CharStream other, IntCharToLongFunction f) {
        return () -> new LongIterator() {
            private IntIterator it = IntStream.this.intIterator();
            private CharIterator jt = other.charIterator();

            public long value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public CharStream join(CharStream other, IntCharToCharFunction f) {
        return () -> new CharIterator() {
            private IntIterator it = IntStream.this.intIterator();
            private CharIterator jt = other.charIterator();

            public char value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }
}
abstract class LongAbstractStream implements LongStream {
    //base
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        boolean first = true;
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            if (first) {
                first = false;
            } else {
                builder.append(' ');
            }
            builder.append(it.value());
        }
        return builder.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof LongStream)) {
            return false;
        }
        LongStream c = (LongStream) o;
        LongIterator it = longIterator();
        LongIterator jt = c.longIterator();
        while (it.isValid() && jt.isValid()) {
            if (it.value() != jt.value()) {
                return false;
            }
            it.advance();
            jt.advance();
        }
        return !it.isValid() && !jt.isValid();
    }

    @Override
    public int hashCode() {
        int result = 0;
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            result *= 31;
            result += it.value();
        }
        return result;
    }
}
/**
 * @author Egor Kulikov
 */
 interface LongCollection extends LongStream {
    //abstract
    public int size();

    //base
    default public boolean isEmpty() {
        return size() == 0;
    }

    default public void add(long value) {
        throw new UnsupportedOperationException();
    }

    default public boolean remove(long value) {
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            if (value == it.value()) {
                it.remove();
                return true;
            }
        }
        return false;
    }

    default public long[] toArray() {
        int size = size();
        long[] array = new long[size];
        int i = 0;
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            array[i++] = it.value();
        }
        return array;
    }

    default public LongCollection addAll(LongStream values) {
        for (LongIterator it = values.longIterator(); it.isValid(); it.advance()) {
            add(it.value());
        }
        return this;
    }

    default public LongCollection removeAll(LongStream values) {
        for (LongIterator it = values.longIterator(); it.isValid(); it.advance()) {
            remove(it.value());
        }
        return this;
    }

    default public LongCollection retainAll(LongCollection values) {
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            if (!values.contains(it.value())) {
                it.remove();
            }
        }
        return this;
    }

    default public LongCollection compute() {
        return this;
    }
}
interface LongReversableCollection extends LongCollection {
    //abstract
    public LongIterator reverseIterator();

    //base
    default public long last() {
        return reverseIterator().value();
    }

    default LongStream reversed() {
        return () -> reverseIterator();
    }
}
interface LongStream extends Iterable<Long>, Comparable<LongStream> {
    //abstract
    public LongIterator longIterator();

    //base
    default public Iterator<Long> iterator() {
        return new Iterator<Long>() {
            private LongIterator it = longIterator();

            public boolean hasNext() {
                return it.isValid();
            }

            public Long next() {
                long result = it.value();
                it.advance();
                return result;
            }
        };
    }

    default public long first() {
        return longIterator().value();
    }

    default public LongCollection compute() {
        return new LongArrayList(this);
    }

    default public int compareTo(LongStream c) {
        LongIterator it = longIterator();
        LongIterator jt = c.longIterator();
        while (it.isValid() && jt.isValid()) {
            long i = it.value();
            long j = jt.value();
            if (i < j) {
                return -1;
            } else if (i > j) {
                return 1;
            }
            it.advance();
            jt.advance();
        }
        if (it.isValid()) {
            return 1;
        }
        if (jt.isValid()) {
            return -1;
        }
        return 0;
    }

    //algorithms
    default public void forEach(LongTask task) {
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            task.process(it.value());
        }
    }

    default public boolean contains(long value) {
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            if (it.value() == value) {
                return true;
            }
        }
        return false;
    }

    default public boolean contains(LongFilter filter) {
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            if (filter.accept(it.value())) {
                return true;
            }
        }
        return false;
    }

    default public int count(long value) {
        int result = 0;
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            if (it.value() == value) {
                result++;
            }
        }
        return result;
    }

    default public int count(LongFilter filter) {
        int result = 0;
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            if (filter.accept(it.value())) {
                result++;
            }
        }
        return result;
    }

    default public long min() {
        long result = Long.MAX_VALUE;
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            long current = it.value();
            if (current < result) {
                result = current;
            }
        }
        return result;
    }

    default public long min(LongComparator comparator) {
        long result = Long.MIN_VALUE;
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            long current = it.value();
            if (result == Long.MIN_VALUE || comparator.compare(result, current) > 0) {
                result = current;
            }
        }
        return result;
    }

    default public long max() {
        long result = Long.MIN_VALUE;
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            long current = it.value();
            if (current > result) {
                result = current;
            }
        }
        return result;
    }

    default public long max(LongComparator comparator) {
        long result = Long.MIN_VALUE;
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            long current = it.value();
            if (result == Long.MIN_VALUE || comparator.compare(result, current) < 0) {
                result = current;
            }
        }
        return result;
    }

    default public long sum() {
        long result = 0;
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            result += it.value();
        }
        return result;
    }

    default public int[] qty(int bound) {
        int[] result = new int[bound];
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            result[(int) it.value()]++;
        }
        return result;
    }

    default public int[] qty() {
        return qty((int) (max() + 1));
    }

    default public boolean allOf(LongFilter f) {
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            if (!f.accept(it.value())) {
                return false;
            }
        }
        return true;
    }

    default public boolean anyOf(LongFilter f) {
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            if (f.accept(it.value())) {
                return true;
            }
        }
        return false;
    }

    default public boolean noneOf(LongFilter f) {
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            if (f.accept(it.value())) {
                return false;
            }
        }
        return true;
    }

    default public long reduce(LongLongToLongFunction f) {
        LongIterator it = longIterator();
        if (!it.isValid()) {
            return Long.MIN_VALUE;
        }
        long result = it.value();
        while (it.advance()) {
            result = f.value(result, it.value());
        }
        return result;
    }

    default public double reduce(double initial, DoubleLongToDoubleFunction f) {
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            initial = f.value(initial, it.value());
        }
        return initial;
    }

    default public int reduce(int initial, IntLongToIntFunction f) {
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            initial = f.value(initial, it.value());
        }
        return initial;
    }

    default public long reduce(long initial, LongLongToLongFunction f) {
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            initial = f.value(initial, it.value());
        }
        return initial;
    }

    default public char reduce(char initial, CharLongToCharFunction f) {
        for (LongIterator it = longIterator(); it.isValid(); it.advance()) {
            initial = f.value(initial, it.value());
        }
        return initial;
    }

    //views
    default public LongStream union(LongStream other) {
        return () -> new LongIterator() {
            private LongIterator first = LongStream.this.longIterator();
            private LongIterator second;

            public long value() throws NoSuchElementException {
                if (first.isValid()) {
                    return first.value();
                }
                return second.value();
            }

            public boolean advance() throws NoSuchElementException {
                if (first.isValid()) {
                    first.advance();
                    if (!first.isValid()) {
                        second = other.longIterator();
                    }
                    return second.isValid();
                } else {
                    return second.advance();
                }
            }

            public boolean isValid() {
                return first.isValid() || second.isValid();
            }

            public void remove() {
                if (first.isValid()) {
                    first.remove();
                } else {
                    second.remove();
                }
            }
        };
    }

    default public LongStream filter(LongFilter f) {
        return () -> new LongIterator() {
            private LongIterator it = LongStream.this.longIterator();

            {
                next();
            }

            private void next() {
                while (it.isValid() && !f.accept(it.value())) {
                    it.advance();
                }
            }

            public long value() {
                return it.value();
            }

            public boolean advance() {
                it.advance();
                next();
                return isValid();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public DoubleStream map(LongToDoubleFunction function) {
        return () -> new DoubleIterator() {
            private LongIterator it = LongStream.this.longIterator();

            public double value() {
                return function.value(it.value());
            }

            public boolean advance() {
                return it.advance();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public IntStream map(LongToIntFunction function) {
        return () -> new IntIterator() {
            private LongIterator it = LongStream.this.longIterator();

            public int value() {
                return function.value(it.value());
            }

            public boolean advance() {
                return it.advance();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public LongStream map(LongToLongFunction function) {
        return () -> new LongIterator() {
            private LongIterator it = LongStream.this.longIterator();

            public long value() {
                return function.value(it.value());
            }

            public boolean advance() {
                return it.advance();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public CharStream map(LongToCharFunction function) {
        return () -> new CharIterator() {
            private LongIterator it = LongStream.this.longIterator();

            public char value() {
                return function.value(it.value());
            }

            public boolean advance() {
                return it.advance();
            }

            public boolean isValid() {
                return it.isValid();
            }

            public void remove() {
                it.remove();
            }
        };
    }

    default public DoubleStream join(DoubleStream other, LongDoubleToDoubleFunction f) {
        return () -> new DoubleIterator() {
            private LongIterator it = LongStream.this.longIterator();
            private DoubleIterator jt = other.doubleIterator();

            public double value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public IntStream join(DoubleStream other, LongDoubleToIntFunction f) {
        return () -> new IntIterator() {
            private LongIterator it = LongStream.this.longIterator();
            private DoubleIterator jt = other.doubleIterator();

            public int value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public LongStream join(DoubleStream other, LongDoubleToLongFunction f) {
        return () -> new LongIterator() {
            private LongIterator it = LongStream.this.longIterator();
            private DoubleIterator jt = other.doubleIterator();

            public long value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public CharStream join(DoubleStream other, LongDoubleToCharFunction f) {
        return () -> new CharIterator() {
            private LongIterator it = LongStream.this.longIterator();
            private DoubleIterator jt = other.doubleIterator();

            public char value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public DoubleStream join(IntStream other, LongIntToDoubleFunction f) {
        return () -> new DoubleIterator() {
            private LongIterator it = LongStream.this.longIterator();
            private IntIterator jt = other.intIterator();

            public double value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public IntStream join(IntStream other, LongIntToIntFunction f) {
        return () -> new IntIterator() {
            private LongIterator it = LongStream.this.longIterator();
            private IntIterator jt = other.intIterator();

            public int value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public LongStream join(IntStream other, LongIntToLongFunction f) {
        return () -> new LongIterator() {
            private LongIterator it = LongStream.this.longIterator();
            private IntIterator jt = other.intIterator();

            public long value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public CharStream join(IntStream other, LongIntToCharFunction f) {
        return () -> new CharIterator() {
            private LongIterator it = LongStream.this.longIterator();
            private IntIterator jt = other.intIterator();

            public char value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public DoubleStream join(LongStream other, LongLongToDoubleFunction f) {
        return () -> new DoubleIterator() {
            private LongIterator it = LongStream.this.longIterator();
            private LongIterator jt = other.longIterator();

            public double value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public IntStream join(LongStream other, LongLongToIntFunction f) {
        return () -> new IntIterator() {
            private LongIterator it = LongStream.this.longIterator();
            private LongIterator jt = other.longIterator();

            public int value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public LongStream join(LongStream other, LongLongToLongFunction f) {
        return () -> new LongIterator() {
            private LongIterator it = LongStream.this.longIterator();
            private LongIterator jt = other.longIterator();

            public long value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public CharStream join(LongStream other, LongLongToCharFunction f) {
        return () -> new CharIterator() {
            private LongIterator it = LongStream.this.longIterator();
            private LongIterator jt = other.longIterator();

            public char value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public DoubleStream join(CharStream other, LongCharToDoubleFunction f) {
        return () -> new DoubleIterator() {
            private LongIterator it = LongStream.this.longIterator();
            private CharIterator jt = other.charIterator();

            public double value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public IntStream join(CharStream other, LongCharToIntFunction f) {
        return () -> new IntIterator() {
            private LongIterator it = LongStream.this.longIterator();
            private CharIterator jt = other.charIterator();

            public int value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public LongStream join(CharStream other, LongCharToLongFunction f) {
        return () -> new LongIterator() {
            private LongIterator it = LongStream.this.longIterator();
            private CharIterator jt = other.charIterator();

            public long value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }

    default public CharStream join(CharStream other, LongCharToCharFunction f) {
        return () -> new CharIterator() {
            private LongIterator it = LongStream.this.longIterator();
            private CharIterator jt = other.charIterator();

            public char value() {
                return f.value(it.value(), jt.value());
            }

            public boolean advance() {
                return it.advance() && jt.advance();
            }

            public boolean isValid() {
                return it.isValid() && jt.isValid();
            }

            public void remove() {
                it.remove();
                jt.remove();
            }
        };
    }
}
/**
 * @author Egor Kulikov (kulikov@devexperts.com)
 */
 class InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public double[] readDoubleArray(int size) {
        double[] array = new double[size];
        for (int i = 0; i < size; i++) {
            array[i] = readDouble();
        }
        return array;
    }

    public String[] readStringArray(int size) {
        String[] array = new String[size];
        for (int i = 0; i < size; i++) {
            array[i] = readString();
        }
        return array;
    }

    public char[] readCharArray(int size) {
        char[] array = new char[size];
        for (int i = 0; i < size; i++) {
            array[i] = readCharacter();
        }
        return array;
    }

    public IntIntPair[] readIntPairArray(int size) {
        IntIntPair[] result = new IntIntPair[size];
        for (int i = 0; i < size; i++) {
            result[i] = readIntPair();
        }
        return result;
    }

    public LongLongPair[] readLongPairArray(int size) {
        LongLongPair[] result = new LongLongPair[size];
        for (int i = 0; i < size; i++) {
            result[i] = readLongPair();
        }
        return result;
    }

    public void readIntArrays(int[]... arrays) {
        for (int i = 0; i < arrays[0].length; i++) {
            for (int j = 0; j < arrays.length; j++) {
                arrays[j][i] = readInt();
            }
        }
    }

    public void readLongArrays(long[]... arrays) {
        for (int i = 0; i < arrays[0].length; i++) {
            for (int j = 0; j < arrays.length; j++) {
                arrays[j][i] = readLong();
            }
        }
    }

    public void readDoubleArrays(double[]... arrays) {
        for (int i = 0; i < arrays[0].length; i++) {
            for (int j = 0; j < arrays.length; j++) {
                arrays[j][i] = readDouble();
            }
        }
    }

    public char[][] readTable(int rowCount, int columnCount) {
        char[][] table = new char[rowCount][];
        for (int i = 0; i < rowCount; i++) {
            table[i] = this.readCharArray(columnCount);
        }
        return table;
    }

    public int[][] readIntTable(int rowCount, int columnCount) {
        int[][] table = new int[rowCount][];
        for (int i = 0; i < rowCount; i++) {
            table[i] = readIntArray(columnCount);
        }
        return table;
    }

    public double[][] readDoubleTable(int rowCount, int columnCount) {
        double[][] table = new double[rowCount][];
        for (int i = 0; i < rowCount; i++) {
            table[i] = this.readDoubleArray(columnCount);
        }
        return table;
    }

    public long[][] readLongTable(int rowCount, int columnCount) {
        long[][] table = new long[rowCount][];
        for (int i = 0; i < rowCount; i++) {
            table[i] = readLongArray(columnCount);
        }
        return table;
    }

    public String[][] readStringTable(int rowCount, int columnCount) {
        String[][] table = new String[rowCount][];
        for (int i = 0; i < rowCount; i++) {
            table[i] = this.readStringArray(columnCount);
        }
        return table;
    }

    public String readText() {
        StringBuilder result = new StringBuilder();
        while (true) {
            int character = read();
            if (character == '\r') {
                continue;
            }
            if (character == -1) {
                break;
            }
            result.append((char) character);
        }
        return result.toString();
    }

    public void readStringArrays(String[]... arrays) {
        for (int i = 0; i < arrays[0].length; i++) {
            for (int j = 0; j < arrays.length; j++) {
                arrays[j][i] = readString();
            }
        }
    }

    public long[] readLongArray(int size) {
        long[] array = new long[size];
        for (int i = 0; i < size; i++) {
            array[i] = readLong();
        }
        return array;
    }

    public int[] readIntArray(int size) {
        int[] array = new int[size];
        for (int i = 0; i < size; i++) {
            array[i] = readInt();
        }
        return array;
    }

    public LongLongPair readLongPair() {
        long first = readLong();
        long second = readLong();
        return new LongLongPair(first, second);
    }

    public IntIntPair readIntPair() {
        int first = readInt();
        int second = readInt();
        return new IntIntPair(first, second);
    }

    public int read() {
        if (numChars == -1) {
            throw new InputMismatchException();
        }
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0) {
                return -1;
            }
        }
        return buf[curChar++];
    }

    public int peek() {
        if (numChars == -1) {
            return -1;
        }
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                return -1;
            }
            if (numChars <= 0) {
                return -1;
            }
        }
        return buf[curChar];
    }

    public int peekNonWhitespace() {
        while (isWhitespace(peek())) {
            read();
        }
        return peek();
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9') {
                throw new InputMismatchException();
            }
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public long readLong() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        long res = 0;
        do {
            if (c < '0' || c > '9') {
                throw new InputMismatchException();
            }
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public String readString() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        StringBuilder res = new StringBuilder();
        do {
            if (Character.isValidCodePoint(c)) {
                res.appendCodePoint(c);
            }
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    public boolean isSpaceChar(int c) {
        if (filter != null) {
            return filter.isSpaceChar(c);
        }
        return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    private String readLine0() {
        StringBuilder buf = new StringBuilder();
        int c = read();
        while (c != '\n' && c != -1) {
            if (c != '\r') {
                buf.appendCodePoint(c);
            }
            c = read();
        }
        return buf.toString();
    }

    public String readLine() {
        String s = readLine0();
        while (s.trim().length() == 0) {
            s = readLine0();
        }
        return s;
    }

    public String readLine(boolean ignoreEmptyLines) {
        if (ignoreEmptyLines) {
            return readLine();
        } else {
            return readLine0();
        }
    }

    public BigInteger readBigInteger() {
        try {
            return new BigInteger(readString());
        } catch (NumberFormatException e) {
            throw new InputMismatchException();
        }
    }

    public char readCharacter() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        return (char) c;
    }

    public double readDouble() {
        int c = read();
        while (isSpaceChar(c)) {
            c = read();
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        double res = 0;
        while (!isSpaceChar(c) && c != '.') {
            if (c == 'e' || c == 'E') {
                return res * Math.pow(10, readInt());
            }
            if (c < '0' || c > '9') {
                throw new InputMismatchException();
            }
            res *= 10;
            res += c - '0';
            c = read();
        }
        if (c == '.') {
            c = read();
            double m = 1;
            while (!isSpaceChar(c)) {
                if (c == 'e' || c == 'E') {
                    return res * Math.pow(10, readInt());
                }
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                m /= 10;
                res += (c - '0') * m;
                c = read();
            }
        }
        return res * sgn;
    }

    public boolean isExhausted() {
        int value;
        while (isSpaceChar(value = peek()) && value != -1) {
            read();
        }
        return value == -1;
    }

    public String next() {
        return readString();
    }

    public SpaceCharFilter getFilter() {
        return filter;
    }

    public void setFilter(SpaceCharFilter filter) {
        this.filter = filter;
    }

     interface SpaceCharFilter {
        public boolean isSpaceChar(int ch);
    }
}
/**
 * @author Egor Kulikov (egor@egork.net)
 */
 class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
        this.writer = new PrintWriter(writer);
    }

    public void printTable(char[][] table) {
        for (char[] row : table) {
            printLine(new String(row));
        }
    }

    public void print(char[] array) {
        writer.print(array);
    }

    public void print(Object... objects) {
        for (int i = 0; i < objects.length; i++) {
            if (i != 0) {
                writer.print(' ');
            }
            writer.print(objects[i]);
        }
    }

    public void print(int[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0) {
                writer.print(' ');
            }
            writer.print(array[i]);
        }
    }

    public void print(double[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0) {
                writer.print(' ');
            }
            writer.print(array[i]);
        }
    }

    public void print(long[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0) {
                writer.print(' ');
            }
            writer.print(array[i]);
        }
    }

    public void printLine(int[] array) {
        print(array);
        writer.println();
    }

    public void printLine(double[] array) {
        print(array);
        writer.println();
    }

    public void printLine(long[] array) {
        print(array);
        writer.println();
    }

    public void printLine() {
        writer.println();
    }

    public void printLine(Object... objects) {
        print(objects);
        writer.println();
    }

    public void print(char i) {
        writer.print(i);
    }

    public void printLine(char i) {
        writer.println(i);
    }

    public void printLine(char[] array) {
        writer.println(array);
    }

    public void printFormat(String format, Object... objects) {
        writer.printf(format, objects);
    }

    public void close() {
        writer.close();
    }

    public void flush() {
        writer.flush();
    }

    public void print(long i) {
        writer.print(i);
    }

    public void printLine(long i) {
        writer.println(i);
    }

    public void print(int i) {
        writer.print(i);
    }

    public void printLine(int i) {
        writer.println(i);
    }

    public void separateLines(int[] array) {
        for (int i : array) {
            printLine(i);
        }
    }

    public void printList(List<?> answer) {
        for (Object o : answer) {
            printLine(o);
        }
    }

    public void printPairList(List<IntIntPair> answer) {
        for (IntIntPair pair : answer) {
            printLine(pair.first, pair.second);
        }
    }
}
/**
 * @author Egor Kulikov
 */
 class CharCharPair implements Comparable<CharCharPair> {
    public final char first;
    public final char second;

    public static CharCharPair makePair(char first, char second) {
        return new CharCharPair(first, second);
    }

    public CharCharPair(char first, char second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        CharCharPair pair = (CharCharPair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = Character.hashCode(first);
        result = 31 * result + Character.hashCode(second);
        return result;
    }

    public CharCharPair swap() {
        return CharCharPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(CharCharPair o) {
        int value = Character.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Character.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class CharDoublePair implements Comparable<CharDoublePair> {
    public final char first;
    public final double second;

    public static CharDoublePair makePair(char first, double second) {
        return new CharDoublePair(first, second);
    }

    public CharDoublePair(char first, double second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        CharDoublePair pair = (CharDoublePair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = Character.hashCode(first);
        result = 31 * result + Double.hashCode(second);
        return result;
    }

    public DoubleCharPair swap() {
        return DoubleCharPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(CharDoublePair o) {
        int value = Character.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Double.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class CharIntPair implements Comparable<CharIntPair> {
    public final char first;
    public final int second;

    public static CharIntPair makePair(char first, int second) {
        return new CharIntPair(first, second);
    }

    public CharIntPair(char first, int second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        CharIntPair pair = (CharIntPair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = Character.hashCode(first);
        result = 31 * result + Integer.hashCode(second);
        return result;
    }

    public IntCharPair swap() {
        return IntCharPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(CharIntPair o) {
        int value = Character.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Integer.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class CharLongPair implements Comparable<CharLongPair> {
    public final char first;
    public final long second;

    public static CharLongPair makePair(char first, long second) {
        return new CharLongPair(first, second);
    }

    public CharLongPair(char first, long second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        CharLongPair pair = (CharLongPair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = Character.hashCode(first);
        result = 31 * result + Long.hashCode(second);
        return result;
    }

    public LongCharPair swap() {
        return LongCharPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(CharLongPair o) {
        int value = Character.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Long.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class CharVPair<V> implements Comparable<CharVPair<V>> {
    public final char first;
    public final V second;

    public static <V> CharVPair<V> makePair(char first, V second) {
        return new CharVPair<V>(first, second);
    }

    private CharVPair(char first, V second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        CharCharPair pair = (CharCharPair) o;

        return first == pair.first && second.equals(pair.second);
    }

    @Override
    public int hashCode() {
        int result = Character.hashCode(first);
        result = 31 * result + second.hashCode();
        return result;
    }

    public KCharPair<V> swap() {
        return KCharPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(CharVPair<V> o) {
        int value = Character.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return ((Comparable<V>) second).compareTo(o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class DoubleCharPair implements Comparable<DoubleCharPair> {
    public final double first;
    public final char second;

    public static DoubleCharPair makePair(double first, char second) {
        return new DoubleCharPair(first, second);
    }

    public DoubleCharPair(double first, char second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        DoubleCharPair pair = (DoubleCharPair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = Double.hashCode(first);
        result = 31 * result + Character.hashCode(second);
        return result;
    }

    public CharDoublePair swap() {
        return CharDoublePair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(DoubleCharPair o) {
        int value = Double.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Character.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class DoubleDoublePair implements Comparable<DoubleDoublePair> {
    public final double first;
    public final double second;

    public static DoubleDoublePair makePair(double first, double second) {
        return new DoubleDoublePair(first, second);
    }

    public DoubleDoublePair(double first, double second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        DoubleDoublePair pair = (DoubleDoublePair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = Double.hashCode(first);
        result = 31 * result + Double.hashCode(second);
        return result;
    }

    public DoubleDoublePair swap() {
        return DoubleDoublePair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(DoubleDoublePair o) {
        int value = Double.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Double.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class DoubleIntPair implements Comparable<DoubleIntPair> {
    public final double first;
    public final int second;

    public static DoubleIntPair makePair(double first, int second) {
        return new DoubleIntPair(first, second);
    }

    public DoubleIntPair(double first, int second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        DoubleIntPair pair = (DoubleIntPair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = Double.hashCode(first);
        result = 31 * result + Integer.hashCode(second);
        return result;
    }

    public IntDoublePair swap() {
        return IntDoublePair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(DoubleIntPair o) {
        int value = Double.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Integer.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class DoubleLongPair implements Comparable<DoubleLongPair> {
    public final double first;
    public final long second;

    public static DoubleLongPair makePair(double first, long second) {
        return new DoubleLongPair(first, second);
    }

    public DoubleLongPair(double first, long second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        DoubleLongPair pair = (DoubleLongPair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = Double.hashCode(first);
        result = 31 * result + Long.hashCode(second);
        return result;
    }

    public LongDoublePair swap() {
        return LongDoublePair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(DoubleLongPair o) {
        int value = Double.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Long.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class DoubleVPair<V> implements Comparable<DoubleVPair<V>> {
    public final double first;
    public final V second;

    public static <V> DoubleVPair<V> makePair(double first, V second) {
        return new DoubleVPair<V>(first, second);
    }

    private DoubleVPair(double first, V second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        DoubleCharPair pair = (DoubleCharPair) o;

        return first == pair.first && second.equals(pair.second);
    }

    @Override
    public int hashCode() {
        int result = Double.hashCode(first);
        result = 31 * result + second.hashCode();
        return result;
    }

    public KDoublePair<V> swap() {
        return KDoublePair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(DoubleVPair<V> o) {
        int value = Double.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return ((Comparable<V>) second).compareTo(o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class IntCharPair implements Comparable<IntCharPair> {
    public final int first;
    public final char second;

    public static IntCharPair makePair(int first, char second) {
        return new IntCharPair(first, second);
    }

    public IntCharPair(int first, char second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        IntCharPair pair = (IntCharPair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = Integer.hashCode(first);
        result = 31 * result + Character.hashCode(second);
        return result;
    }

    public CharIntPair swap() {
        return CharIntPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(IntCharPair o) {
        int value = Integer.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Character.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class IntDoublePair implements Comparable<IntDoublePair> {
    public final int first;
    public final double second;

    public static IntDoublePair makePair(int first, double second) {
        return new IntDoublePair(first, second);
    }

    public IntDoublePair(int first, double second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        IntDoublePair pair = (IntDoublePair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = Integer.hashCode(first);
        result = 31 * result + Double.hashCode(second);
        return result;
    }

    public DoubleIntPair swap() {
        return DoubleIntPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(IntDoublePair o) {
        int value = Integer.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Double.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class IntIntPair implements Comparable<IntIntPair> {
    public final int first;
    public final int second;

    public static IntIntPair makePair(int first, int second) {
        return new IntIntPair(first, second);
    }

    public IntIntPair(int first, int second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        IntIntPair pair = (IntIntPair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = first;
        result = 31 * result + second;
        return result;
    }

    public IntIntPair swap() {
        return IntIntPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(IntIntPair o) {
        int value = Integer.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Integer.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class IntLongPair implements Comparable<IntLongPair> {
    public final int first;
    public final long second;

    public static IntLongPair makePair(int first, long second) {
        return new IntLongPair(first, second);
    }

    public IntLongPair(int first, long second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        IntLongPair pair = (IntLongPair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = Integer.hashCode(first);
        result = 31 * result + Long.hashCode(second);
        return result;
    }

    public LongIntPair swap() {
        return LongIntPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(IntLongPair o) {
        int value = Integer.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Long.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class IntVPair<V> implements Comparable<IntVPair<V>> {
    public final int first;
    public final V second;

    public static <V> IntVPair<V> makePair(int first, V second) {
        return new IntVPair<V>(first, second);
    }

    private IntVPair(int first, V second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        IntCharPair pair = (IntCharPair) o;

        return first == pair.first && second.equals(pair.second);
    }

    @Override
    public int hashCode() {
        int result = Integer.hashCode(first);
        result = 31 * result + second.hashCode();
        return result;
    }

    public KIntPair<V> swap() {
        return KIntPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(IntVPair<V> o) {
        int value = Integer.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return ((Comparable<V>) second).compareTo(o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class KCharPair<K> implements Comparable<KCharPair<K>> {
    public final K first;
    public final char second;

    public static <K> KCharPair<K> makePair(K first, char second) {
        return new KCharPair<K>(first, second);
    }

    private KCharPair(K first, char second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        CharCharPair pair = (CharCharPair) o;

        return first.equals(pair.first) && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = first.hashCode();
        result = 31 * result + Character.hashCode(second);
        return result;
    }

    public CharVPair<K> swap() {
        return CharVPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(KCharPair<K> o) {
        int value = ((Comparable<K>) first).compareTo(o.first);
        if (value != 0) {
            return value;
        }
        return Character.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class KDoublePair<K> implements Comparable<KDoublePair<K>> {
    public final K first;
    public final double second;

    public static <K> KDoublePair<K> makePair(K first, double second) {
        return new KDoublePair<K>(first, second);
    }

    private KDoublePair(K first, double second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        CharDoublePair pair = (CharDoublePair) o;

        return first.equals(pair.first) && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = first.hashCode();
        result = 31 * result + Double.hashCode(second);
        return result;
    }

    public DoubleVPair<K> swap() {
        return DoubleVPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(KDoublePair<K> o) {
        int value = ((Comparable<K>) first).compareTo(o.first);
        if (value != 0) {
            return value;
        }
        return Double.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class KIntPair<K> implements Comparable<KIntPair<K>> {
    public final K first;
    public final int second;

    public static <K> KIntPair<K> makePair(K first, int second) {
        return new KIntPair<K>(first, second);
    }

    private KIntPair(K first, int second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        CharIntPair pair = (CharIntPair) o;

        return first.equals(pair.first) && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = first.hashCode();
        result = 31 * result + Integer.hashCode(second);
        return result;
    }

    public IntVPair<K> swap() {
        return IntVPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(KIntPair<K> o) {
        int value = ((Comparable<K>) first).compareTo(o.first);
        if (value != 0) {
            return value;
        }
        return Integer.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class KLongPair<K> implements Comparable<KLongPair<K>> {
    public final K first;
    public final long second;

    public static <K> KLongPair<K> makePair(K first, long second) {
        return new KLongPair<K>(first, second);
    }

    private KLongPair(K first, long second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        CharLongPair pair = (CharLongPair) o;

        return first.equals(pair.first) && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = first.hashCode();
        result = 31 * result + Long.hashCode(second);
        return result;
    }

    public LongVPair<K> swap() {
        return LongVPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(KLongPair<K> o) {
        int value = ((Comparable<K>) first).compareTo(o.first);
        if (value != 0) {
            return value;
        }
        return Long.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class LongCharPair implements Comparable<LongCharPair> {
    public final long first;
    public final char second;

    public static LongCharPair makePair(long first, char second) {
        return new LongCharPair(first, second);
    }

    public LongCharPair(long first, char second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        LongCharPair pair = (LongCharPair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = Long.hashCode(first);
        result = 31 * result + Character.hashCode(second);
        return result;
    }

    public CharLongPair swap() {
        return CharLongPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(LongCharPair o) {
        int value = Long.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Character.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class LongDoublePair implements Comparable<LongDoublePair> {
    public final long first;
    public final double second;

    public static LongDoublePair makePair(long first, double second) {
        return new LongDoublePair(first, second);
    }

    public LongDoublePair(long first, double second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        LongDoublePair pair = (LongDoublePair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = Long.hashCode(first);
        result = 31 * result + Double.hashCode(second);
        return result;
    }

    public DoubleLongPair swap() {
        return DoubleLongPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(LongDoublePair o) {
        int value = Long.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Double.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class LongIntPair implements Comparable<LongIntPair> {
    public final long first;
    public final int second;

    public static LongIntPair makePair(long first, int second) {
        return new LongIntPair(first, second);
    }

    public LongIntPair(long first, int second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        LongIntPair pair = (LongIntPair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = Long.hashCode(first);
        result = 31 * result + Integer.hashCode(second);
        return result;
    }

    public IntLongPair swap() {
        return IntLongPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(LongIntPair o) {
        int value = Long.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Integer.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class LongLongPair implements Comparable<LongLongPair> {
    public final long first;
    public final long second;

    public static LongLongPair makePair(long first, long second) {
        return new LongLongPair(first, second);
    }

    public LongLongPair(long first, long second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        LongLongPair pair = (LongLongPair) o;

        return first == pair.first && second == pair.second;
    }

    @Override
    public int hashCode() {
        int result = Long.hashCode(first);
        result = 31 * result + Long.hashCode(second);
        return result;
    }

    public LongLongPair swap() {
        return LongLongPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(LongLongPair o) {
        int value = Long.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return Long.compare(second, o.second);
    }
}
/**
 * @author Egor Kulikov
 */
 class LongVPair<V> implements Comparable<LongVPair<V>> {
    public final long first;
    public final V second;

    public static <V> LongVPair<V> makePair(long first, V second) {
        return new LongVPair<V>(first, second);
    }

    private LongVPair(long first, V second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        LongCharPair pair = (LongCharPair) o;

        return first == pair.first && second.equals(pair.second);
    }

    @Override
    public int hashCode() {
        int result = Long.hashCode(first);
        result = 31 * result + second.hashCode();
        return result;
    }

    public KLongPair<V> swap() {
        return KLongPair.makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({"unchecked"})
    public int compareTo(LongVPair<V> o) {
        int value = Long.compare(first, o.first);
        if (value != 0) {
            return value;
        }
        return ((Comparable<V>) second).compareTo(o.second);
    }
}